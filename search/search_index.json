{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The Cell Ontology \u00b6 The Cell Ontology (CL) is an OBO Foundry ontology covering the domain of canonical, natural biological cell types. OLS \u00b6 The recommended way to browse the ontology is through the ontology lookup service (OLS) . Accessing CL \u00b6 The main release files can be found in our GitHub repository . The main release file can also be found here . Contributing \u00b6 To see how you can contribute to the cell ontology, please visit our Contributing page . Documentation \u00b6 The documentations here is intended for maintainers and editors of the cell ontology. For general guidance on editing OBO-(ish) ontologies, please see the obook . Cell Ontology Website \u00b6 You can also access our front facing website at https://cell-ontology.github.io/","title":"Getting started"},{"location":"#the-cell-ontology","text":"The Cell Ontology (CL) is an OBO Foundry ontology covering the domain of canonical, natural biological cell types.","title":"The Cell Ontology"},{"location":"#ols","text":"The recommended way to browse the ontology is through the ontology lookup service (OLS) .","title":"OLS"},{"location":"#accessing-cl","text":"The main release files can be found in our GitHub repository . The main release file can also be found here .","title":"Accessing CL"},{"location":"#contributing","text":"To see how you can contribute to the cell ontology, please visit our Contributing page .","title":"Contributing"},{"location":"#documentation","text":"The documentations here is intended for maintainers and editors of the cell ontology. For general guidance on editing OBO-(ish) ontologies, please see the obook .","title":"Documentation"},{"location":"#cell-ontology-website","text":"You can also access our front facing website at https://cell-ontology.github.io/","title":"Cell Ontology Website"},{"location":"Adding_classes_from_another_ontology/","text":"How to add (import) classes to the Cell Ontology (CL) from another ontology \u00b6 NOTE To add PRO terms, please follow first the instructions to add the terms into pro obo slim . 1. Follow steps 1 - 5 under the heading Protege-based declaration. \u00b6 NB: Even though the instructions state that this workflow is to be avoided, the other solutions in the current documentation are out of date. 2. Refresh the imports \u00b6 To refresh the imports, open Docker so it is running in the background. Then open Terminal, navigate to src/ontology directory in the cell-ontology repository and run: sh run.sh make imports/merged_import.owl Running the above command requires > 8GB RAM and sufficient computational power. If the refresh fails to complete due to hardware limitations, create a new issue in GitHub detailing which class(es) need to be imported and another editor can add it on your behalf. Once the imports are refreshed, return to Prot\u00e9g\u00e9, add the logical axioms that include the newly imported class(es) and create a pull request per standard procedure. Note that the import refresh process seems to be quite laborious/computationally expensive as-is, and a centralised database approach may be an improved longterm solution.","title":"Importing classes from another ontology"},{"location":"Adding_classes_from_another_ontology/#how-to-add-import-classes-to-the-cell-ontology-cl-from-another-ontology","text":"NOTE To add PRO terms, please follow first the instructions to add the terms into pro obo slim .","title":"How to add (import) classes to the Cell Ontology (CL) from another ontology"},{"location":"Adding_classes_from_another_ontology/#1-follow-steps-1-5-under-the-heading-protege-based-declaration","text":"NB: Even though the instructions state that this workflow is to be avoided, the other solutions in the current documentation are out of date.","title":"1. Follow steps 1 - 5 under the heading Protege-based declaration."},{"location":"Adding_classes_from_another_ontology/#2-refresh-the-imports","text":"To refresh the imports, open Docker so it is running in the background. Then open Terminal, navigate to src/ontology directory in the cell-ontology repository and run: sh run.sh make imports/merged_import.owl Running the above command requires > 8GB RAM and sufficient computational power. If the refresh fails to complete due to hardware limitations, create a new issue in GitHub detailing which class(es) need to be imported and another editor can add it on your behalf. Once the imports are refreshed, return to Prot\u00e9g\u00e9, add the logical axioms that include the newly imported class(es) and create a pull request per standard procedure. Note that the import refresh process seems to be quite laborious/computationally expensive as-is, and a centralised database approach may be an improved longterm solution.","title":"2. Refresh the imports"},{"location":"Create_upper_level_slim/","text":"SOP for adding a new slim: \u00b6 Intro \u00b6 An upper slim is a set of terms for summarising annotations. CL has both a general slim and domain-specific slims allowing for the generation of general summaries or for domain specific ones. All slims have a context that covers all cells in the domain of interest. In order to fullfil the summarising use-case, a slim should have good % coverage of the domain and, if possible, avoid excluding major cell types. The following are potentially a problem for the grouping use-case: Classes in the slim with very small numbers of subclasses: Having 0-1 subclass => no capacity to summarise. Classes with disproportionately large numbers of subclasses. Overlapping classes - these clash with some types of summary - e.g. pie charts. Potential clashing concerns: It seems reasonable to want to make sure that very important cell types are covered and are not obscured in generating summaries, but this desire can clash with the considerations above. Some judgement is needed to balance these concerns. There is no perfect solution, but some solutions are better (at fulfilling the use case) than others. Name and definition \u00b6 It is important that the name of the slim accurately reflects the content it covers. Specifically, if the intention is to cover all cell types that are specific for an organ, the slim's name should be in the format of \"organ_upper_slim\". This ensures clarity and helps users understand the scope of the slim. Furthermore, the description of the slim should follow a consistent pattern. It is recommended to use the following structure: \"a subset of general classes related to specific cell types in the [organ or specific context]\". This format provides a concise and informative description of the slim, helping users identify its purpose and content. What files to create and edit \u00b6 1. Preparing the subset: \u00b6 Create XXX_upper_slim in Protege (change \"XXX\" to the subset label). See Adding a new Subset . Create a CSV table with the following characteristics (Find examples in src/templates ): 3 columns ID subset label ID AI oboInOwl:inSubset CL:####### http://purl.obolibrary.org/obo/cl#XXX_upper_slim CL term ... http://purl.obolibrary.org/obo/cl#XXX_upper_slim ... Save the CSV file with the name 'XXX_upper_slim.csv' in the src/templates directory. Modify src/ontology/cl-odk.yaml introducing new lines for the new slim (change \"XXX\" to the subset label): - id: XXX_upper_slim - filename: XXX_upper_slim.owl use_template: True templates: - XXX_upper_slim.csv ![image](https://github.com/obophenotype/cell-ontology/assets/94959119/254ad25f-7bf2-4ac2-afe2-9ad067d9c1ea) 2. Generating the Slim OWL file: \u00b6 Navigate to the src/ontology file in the terminal. Make sure Docker is running. Run the command: sh run.sh make update_repo 3. Modifying the Catalog: \u00b6 Open the src/ontology/catalog-v001.xml file. Add the following line (change \"XXX\" to the subset label): <uri name=\"http://purl.obolibrary.org/obo/cl/components/XXX_upper_slim.owl\" uri=\"components/XXX_upper_slim.owl\"/>` - 4. Preparing the Upper Level Slim import to CL: \u00b6 Open src/ontology/cl-edit.owl . Add the following import statement (change \"XXX\" to the subset label): Import(<http://purl.obolibrary.org/obo/cl/components/XXX_upper_slim.owl>) 5. Updating the slim owl file: \u00b6 Run the command: sh run.sh make all_subsets -B - Alternatively, run the following command to run it anyway even if it says it is up to date (change \"XXX\" to the subset label): sh run.sh make components/XXX_upper_slim.owl -B 6. Testing Slim Coverage: \u00b6 Open src/ontology/cl.Makefile . Add the subset label to SLIM_TEMPLATES (without _upper_slim!!!). Add the term that will be used to test coverage Add: $(REPORTDIR)/XXX_upper_slim.csv: $(TEMPLATEDIR)/XXX_upper_slim.csv $(eval TERM_ID := $(YYY)) $(COVERAGECMD) (substitute \"XXX\" to the subset label and YYY for the tested label) ![image](https://github.com/obophenotype/cell-ontology/assets/94959119/7eb18255-0ef7-4fbc-9f7f-e582372165bf) Using the terminal, navigate to src/ontology . Run the command: sh run.sh make slim_coverage Understanding reports \u00b6 The reports can be accessed at src/ontology/reports/XXX_upper_slim.csv . First, the coverage percentage is displayed, indicating the proportion of cells covered. Secondly, the number of cells covered by each term of the subset is provided. Finally, a list is presented, indicating all the terms that were expected to be covered but are not currently included. Ideally, terms would have more than 1 cell covered. Furthermore, a term covering hundreds of cells might indicate that it is too general, and a more specific term (or multiple) should be evaluated, specially if it overlaps with other terms of the subset. Example: For the eye_upper_slim, 'retinal cell' is a (too) general term that overlaps other grouping terms such as 'retinal bipolar neuron', 'retina horizontal cell' or 'amacrine cell'. In the case that there is overlapping of terms (term A in the subset covers term B of the subset), a coverage file will be created and it can be accessed at src/ontology/reports/overlapping_terms_XXX_upper_slim.csv .","title":"SOP for adding a new slim:"},{"location":"Create_upper_level_slim/#sop-for-adding-a-new-slim","text":"","title":"SOP for adding a new slim:"},{"location":"Create_upper_level_slim/#intro","text":"An upper slim is a set of terms for summarising annotations. CL has both a general slim and domain-specific slims allowing for the generation of general summaries or for domain specific ones. All slims have a context that covers all cells in the domain of interest. In order to fullfil the summarising use-case, a slim should have good % coverage of the domain and, if possible, avoid excluding major cell types. The following are potentially a problem for the grouping use-case: Classes in the slim with very small numbers of subclasses: Having 0-1 subclass => no capacity to summarise. Classes with disproportionately large numbers of subclasses. Overlapping classes - these clash with some types of summary - e.g. pie charts. Potential clashing concerns: It seems reasonable to want to make sure that very important cell types are covered and are not obscured in generating summaries, but this desire can clash with the considerations above. Some judgement is needed to balance these concerns. There is no perfect solution, but some solutions are better (at fulfilling the use case) than others.","title":"Intro"},{"location":"Create_upper_level_slim/#name-and-definition","text":"It is important that the name of the slim accurately reflects the content it covers. Specifically, if the intention is to cover all cell types that are specific for an organ, the slim's name should be in the format of \"organ_upper_slim\". This ensures clarity and helps users understand the scope of the slim. Furthermore, the description of the slim should follow a consistent pattern. It is recommended to use the following structure: \"a subset of general classes related to specific cell types in the [organ or specific context]\". This format provides a concise and informative description of the slim, helping users identify its purpose and content.","title":"Name and definition"},{"location":"Create_upper_level_slim/#what-files-to-create-and-edit","text":"","title":"What files to create and edit"},{"location":"Create_upper_level_slim/#1-preparing-the-subset","text":"Create XXX_upper_slim in Protege (change \"XXX\" to the subset label). See Adding a new Subset . Create a CSV table with the following characteristics (Find examples in src/templates ): 3 columns ID subset label ID AI oboInOwl:inSubset CL:####### http://purl.obolibrary.org/obo/cl#XXX_upper_slim CL term ... http://purl.obolibrary.org/obo/cl#XXX_upper_slim ... Save the CSV file with the name 'XXX_upper_slim.csv' in the src/templates directory. Modify src/ontology/cl-odk.yaml introducing new lines for the new slim (change \"XXX\" to the subset label): - id: XXX_upper_slim - filename: XXX_upper_slim.owl use_template: True templates: - XXX_upper_slim.csv ![image](https://github.com/obophenotype/cell-ontology/assets/94959119/254ad25f-7bf2-4ac2-afe2-9ad067d9c1ea)","title":"1. Preparing the subset:"},{"location":"Create_upper_level_slim/#2-generating-the-slim-owl-file","text":"Navigate to the src/ontology file in the terminal. Make sure Docker is running. Run the command: sh run.sh make update_repo","title":"2. Generating the Slim OWL file:"},{"location":"Create_upper_level_slim/#3-modifying-the-catalog","text":"Open the src/ontology/catalog-v001.xml file. Add the following line (change \"XXX\" to the subset label): <uri name=\"http://purl.obolibrary.org/obo/cl/components/XXX_upper_slim.owl\" uri=\"components/XXX_upper_slim.owl\"/>` -","title":"3. Modifying the Catalog:"},{"location":"Create_upper_level_slim/#4-preparing-the-upper-level-slim-import-to-cl","text":"Open src/ontology/cl-edit.owl . Add the following import statement (change \"XXX\" to the subset label): Import(<http://purl.obolibrary.org/obo/cl/components/XXX_upper_slim.owl>)","title":"4. Preparing the Upper Level Slim import to CL:"},{"location":"Create_upper_level_slim/#5-updating-the-slim-owl-file","text":"Run the command: sh run.sh make all_subsets -B - Alternatively, run the following command to run it anyway even if it says it is up to date (change \"XXX\" to the subset label): sh run.sh make components/XXX_upper_slim.owl -B","title":"5. Updating the slim owl file:"},{"location":"Create_upper_level_slim/#6-testing-slim-coverage","text":"Open src/ontology/cl.Makefile . Add the subset label to SLIM_TEMPLATES (without _upper_slim!!!). Add the term that will be used to test coverage Add: $(REPORTDIR)/XXX_upper_slim.csv: $(TEMPLATEDIR)/XXX_upper_slim.csv $(eval TERM_ID := $(YYY)) $(COVERAGECMD) (substitute \"XXX\" to the subset label and YYY for the tested label) ![image](https://github.com/obophenotype/cell-ontology/assets/94959119/7eb18255-0ef7-4fbc-9f7f-e582372165bf) Using the terminal, navigate to src/ontology . Run the command: sh run.sh make slim_coverage","title":"6. Testing Slim Coverage:"},{"location":"Create_upper_level_slim/#understanding-reports","text":"The reports can be accessed at src/ontology/reports/XXX_upper_slim.csv . First, the coverage percentage is displayed, indicating the proportion of cells covered. Secondly, the number of cells covered by each term of the subset is provided. Finally, a list is presented, indicating all the terms that were expected to be covered but are not currently included. Ideally, terms would have more than 1 cell covered. Furthermore, a term covering hundreds of cells might indicate that it is too general, and a more specific term (or multiple) should be evaluated, specially if it overlaps with other terms of the subset. Example: For the eye_upper_slim, 'retinal cell' is a (too) general term that overlaps other grouping terms such as 'retinal bipolar neuron', 'retina horizontal cell' or 'amacrine cell'. In the case that there is overlapping of terms (term A in the subset covers term B of the subset), a coverage file will be created and it can be accessed at src/ontology/reports/overlapping_terms_XXX_upper_slim.csv .","title":"Understanding reports"},{"location":"Fixing_xsdstring_diffs/","text":"Fixing ^^xsd:string Diffs \u00b6 When you make edits, sometimes there will be large amounts of unintended differences that show up that involves the removal of ^^xsd:string . If so, you can resolve them by following normalising your cl-edit.owl file. SOP \u00b6 Update your file from Master (see 'How to resolve merge conflicts' for instructions on how to do this including how to resolve clashes while doing this). in the terminal, set directory to the ontology folder in CL: cd .../GitHub/cell-ontology/src/ontology Run the normaliser in terminal: If you have docker installed: sh run.sh make normalise_xsd_string If you do not have docker installed: make normalise_xsd_string If make is not installed, on MAC: sed -i '' -E \"s/Annotation[(](oboInOwl[:]hasDbXref [\\\"][^\\\"]*[\\\"])[)]/Annotation(\\1^^xsd:string)/g\" cl-edit.owl This should resolve your ^^xsd:string issue, after which, you can handle your pull request as per usual.","title":"Fixing unintended ^^xsd:string diffs"},{"location":"Fixing_xsdstring_diffs/#fixing-xsdstring-diffs","text":"When you make edits, sometimes there will be large amounts of unintended differences that show up that involves the removal of ^^xsd:string . If so, you can resolve them by following normalising your cl-edit.owl file.","title":"Fixing ^^xsd:string Diffs"},{"location":"Fixing_xsdstring_diffs/#sop","text":"Update your file from Master (see 'How to resolve merge conflicts' for instructions on how to do this including how to resolve clashes while doing this). in the terminal, set directory to the ontology folder in CL: cd .../GitHub/cell-ontology/src/ontology Run the normaliser in terminal: If you have docker installed: sh run.sh make normalise_xsd_string If you do not have docker installed: make normalise_xsd_string If make is not installed, on MAC: sed -i '' -E \"s/Annotation[(](oboInOwl[:]hasDbXref [\\\"][^\\\"]*[\\\"])[)]/Annotation(\\1^^xsd:string)/g\" cl-edit.owl This should resolve your ^^xsd:string issue, after which, you can handle your pull request as per usual.","title":"SOP"},{"location":"Keeping_ontology_terms_up_to_date/","text":"Keeping cell ontology annotation up to date \u00b6 Cell ontology identifiers (IRIs) are never lost, but they are occasionally deprecated. On the rare occasions that this happens, all logical links to other ontology terms (e.g. recording classification or partonomy) are removed and term is tagged with the annotation owl:deprecated True . To aid migration of annotations to the latest standard, these terms are also annotated with either a term_replaced_by or a consider tag. A term_replaced_by annotation is used to record the ID of a term it is safe to auto-migrate annotations to. More rarely, consider is used to record multiple potential replacement terms requiring human consideration to map. In these cases, a comment will be present to provide guidance for mapping. The Ontology Lookup Service API provides a convenient way to check for deprecated terms & find replacements. The term http://purl.obolibrary.org/obo/CL_0000375 has been deprecated and has that tag term_replaced_by Querying the OLS API for this: https://www.ebi.ac.uk/ols/api/ontologies/cl/terms/http%253A%252F%252Fpurl.obolibrary.org%252Fobo%252FCL_0000375. (Note the query IRI must be double encoded) Returns: { \"iri\" : \"http://purl.obolibrary.org/obo/CL_0000375\", \"label\" : \"obsolete osteoprogenitor cell\", \"description\" : null, \"annotation\" : { \"database_cross_reference\" : [ \"BTO:0002051\" ], \"has_obo_namespace\" : [ \"cell\" ], \"term replaced by\" : [ \"CL:0007010\" ] }, \"synonyms\" : null, \"ontology_name\" : \"cl\", \"ontology_prefix\" : \"CL\", \"ontology_iri\" : \"http://purl.obolibrary.org/obo/cl.owl\", \"is_obsolete\" : true, \"term_replaced_by\" : \"CL:0007010\", \"is_defining_ontology\" : true, \"has_children\" : false, \"is_root\" : true, \"short_form\" : \"CL_0000375\", \"obo_id\" : \"CL:0000375\", \"in_subset\" : null, \"obo_definition_citation\" : null, \"obo_xref\" : [{\"database\":\"BTO\",\"id\":\"0002051\",\"description\":null,\"url\":\"http://purl.obolibrary.org/obo/BTO_0002051\"}], \"obo_synonym\" : null, \"is_preferred_root\" : false, \"_links\" : { \"self\" : { \"href\" : \"https://www.ebi.ac.uk/ols/api/ontologies/cl/terms/http%253A%252F%252Fpurl.obolibrary.org%252Fobo%252FCL_0000375\" }, \"graph\" : { \"href\" : \"https://www.ebi.ac.uk/ols/api/ontologies/cl/terms/http%253A%252F%252Fpurl.obolibrary.org%252Fobo%252FCL_0000375/graph\" } } } The term_replaced_by key points to the ID of a safe replacement term: CL:0007010. This is a CURIE for http://purl.obolibrary.org/obo/CL_0007010 * consider The term http://purl.obolibrary.org/obo/CL_0000144 has been deprecated and has a consider tag pointing to multiple possible replacement terms, along with a comment for guidance. Querying the OLS API for this: https://www.ebi.ac.uk/ols/api/ontologies/cl/terms/http%253A%252F%252Fpurl.obolibrary.org%252Fobo%252FCL_0000144 Returns { \"iri\" : \"http://purl.obolibrary.org/obo/CL_0000144\", \"label\" : \"obsolete cell by function\", \"description\" : [ \"OBSOLETE: A classification of cells by their primary end goal or behavior.\" ], \"annotation\" : { \"comment\" : [ \"This term was made obsolete because there is no difference in meaning between it and 'cell', as any cell can be classified by its function or behavior. If you have used this term in annotation, please replace it with cell (CL:0000000), native cell (CL:0000003), or cell in vitro (CL:0001034) as appropriate.\" ], \"consider\" : [ \"CL:0001034\", \"CL:0000000\", \"CL:0000003\" ], \"has_obo_namespace\" : [ \"cell\" ] }, \"synonyms\" : null, \"ontology_name\" : \"cl\", \"ontology_prefix\" : \"CL\", \"ontology_iri\" : \"http://purl.obolibrary.org/obo/cl.owl\", \"is_obsolete\" : true, \"term_replaced_by\" : null, \"is_defining_ontology\" : true, \"has_children\" : false, \"is_root\" : true, \"short_form\" : \"CL_0000144\", \"obo_id\" : \"CL:0000144\", \"in_subset\" : null, \"obo_definition_citation\" : [{\"definition\":\"OBSOLETE: A classification of cells by their primary end goal or behavior.\",\"oboXrefs\":[{\"database\":\"FB\",\"id\":\"ma\",\"description\":null,\"url\":\"http://flybase.org/reports/ma.html\"}]}], \"obo_xref\" : null, \"obo_synonym\" : null, \"is_preferred_root\" : false, \"_links\" : { \"self\" : { \"href\" : \"https://www.ebi.ac.uk/ols/api/ontologies/cl/terms/http%253A%252F%252Fpurl.obolibrary.org%252Fobo%252FCL_0000144\" }, \"graph\" : { \"href\" : \"https://www.ebi.ac.uk/ols/api/ontologies/cl/terms/http%253A%252F%252Fpurl.obolibrary.org%252Fobo%252FCL_0000144/graph\" } } } * Warning - due to legacy issues, the values of these tags are either a curie (CL:0000123) or short_form ID (CL_0000123) rather than an iri. Handling code needs to deal with both of these formats.","title":"Keep terms up-to-date"},{"location":"Keeping_ontology_terms_up_to_date/#keeping-cell-ontology-annotation-up-to-date","text":"Cell ontology identifiers (IRIs) are never lost, but they are occasionally deprecated. On the rare occasions that this happens, all logical links to other ontology terms (e.g. recording classification or partonomy) are removed and term is tagged with the annotation owl:deprecated True . To aid migration of annotations to the latest standard, these terms are also annotated with either a term_replaced_by or a consider tag. A term_replaced_by annotation is used to record the ID of a term it is safe to auto-migrate annotations to. More rarely, consider is used to record multiple potential replacement terms requiring human consideration to map. In these cases, a comment will be present to provide guidance for mapping. The Ontology Lookup Service API provides a convenient way to check for deprecated terms & find replacements. The term http://purl.obolibrary.org/obo/CL_0000375 has been deprecated and has that tag term_replaced_by Querying the OLS API for this: https://www.ebi.ac.uk/ols/api/ontologies/cl/terms/http%253A%252F%252Fpurl.obolibrary.org%252Fobo%252FCL_0000375. (Note the query IRI must be double encoded) Returns: { \"iri\" : \"http://purl.obolibrary.org/obo/CL_0000375\", \"label\" : \"obsolete osteoprogenitor cell\", \"description\" : null, \"annotation\" : { \"database_cross_reference\" : [ \"BTO:0002051\" ], \"has_obo_namespace\" : [ \"cell\" ], \"term replaced by\" : [ \"CL:0007010\" ] }, \"synonyms\" : null, \"ontology_name\" : \"cl\", \"ontology_prefix\" : \"CL\", \"ontology_iri\" : \"http://purl.obolibrary.org/obo/cl.owl\", \"is_obsolete\" : true, \"term_replaced_by\" : \"CL:0007010\", \"is_defining_ontology\" : true, \"has_children\" : false, \"is_root\" : true, \"short_form\" : \"CL_0000375\", \"obo_id\" : \"CL:0000375\", \"in_subset\" : null, \"obo_definition_citation\" : null, \"obo_xref\" : [{\"database\":\"BTO\",\"id\":\"0002051\",\"description\":null,\"url\":\"http://purl.obolibrary.org/obo/BTO_0002051\"}], \"obo_synonym\" : null, \"is_preferred_root\" : false, \"_links\" : { \"self\" : { \"href\" : \"https://www.ebi.ac.uk/ols/api/ontologies/cl/terms/http%253A%252F%252Fpurl.obolibrary.org%252Fobo%252FCL_0000375\" }, \"graph\" : { \"href\" : \"https://www.ebi.ac.uk/ols/api/ontologies/cl/terms/http%253A%252F%252Fpurl.obolibrary.org%252Fobo%252FCL_0000375/graph\" } } } The term_replaced_by key points to the ID of a safe replacement term: CL:0007010. This is a CURIE for http://purl.obolibrary.org/obo/CL_0007010 * consider The term http://purl.obolibrary.org/obo/CL_0000144 has been deprecated and has a consider tag pointing to multiple possible replacement terms, along with a comment for guidance. Querying the OLS API for this: https://www.ebi.ac.uk/ols/api/ontologies/cl/terms/http%253A%252F%252Fpurl.obolibrary.org%252Fobo%252FCL_0000144 Returns { \"iri\" : \"http://purl.obolibrary.org/obo/CL_0000144\", \"label\" : \"obsolete cell by function\", \"description\" : [ \"OBSOLETE: A classification of cells by their primary end goal or behavior.\" ], \"annotation\" : { \"comment\" : [ \"This term was made obsolete because there is no difference in meaning between it and 'cell', as any cell can be classified by its function or behavior. If you have used this term in annotation, please replace it with cell (CL:0000000), native cell (CL:0000003), or cell in vitro (CL:0001034) as appropriate.\" ], \"consider\" : [ \"CL:0001034\", \"CL:0000000\", \"CL:0000003\" ], \"has_obo_namespace\" : [ \"cell\" ] }, \"synonyms\" : null, \"ontology_name\" : \"cl\", \"ontology_prefix\" : \"CL\", \"ontology_iri\" : \"http://purl.obolibrary.org/obo/cl.owl\", \"is_obsolete\" : true, \"term_replaced_by\" : null, \"is_defining_ontology\" : true, \"has_children\" : false, \"is_root\" : true, \"short_form\" : \"CL_0000144\", \"obo_id\" : \"CL:0000144\", \"in_subset\" : null, \"obo_definition_citation\" : [{\"definition\":\"OBSOLETE: A classification of cells by their primary end goal or behavior.\",\"oboXrefs\":[{\"database\":\"FB\",\"id\":\"ma\",\"description\":null,\"url\":\"http://flybase.org/reports/ma.html\"}]}], \"obo_xref\" : null, \"obo_synonym\" : null, \"is_preferred_root\" : false, \"_links\" : { \"self\" : { \"href\" : \"https://www.ebi.ac.uk/ols/api/ontologies/cl/terms/http%253A%252F%252Fpurl.obolibrary.org%252Fobo%252FCL_0000144\" }, \"graph\" : { \"href\" : \"https://www.ebi.ac.uk/ols/api/ontologies/cl/terms/http%253A%252F%252Fpurl.obolibrary.org%252Fobo%252FCL_0000144/graph\" } } } * Warning - due to legacy issues, the values of these tags are either a curie (CL:0000123) or short_form ID (CL_0000123) rather than an iri. Handling code needs to deal with both of these formats.","title":"Keeping cell ontology annotation up to date"},{"location":"LLM_prompt_guidelines_for_CL_definitions/","text":"A Guide to Using LLm Prompts to Generate Textual Definitions in the Cell Ontology (CL). \u00b6 This guide explains how to efficiently use an LLM prompt to generate CL textual definitions and outlines the steps to refine them to align with CL definition guidelines. 1. Generate Definitions Using the Standard Prompt \u00b6 Standard LLM Prompt \u00b6 System Role: You are an expert cell biologist with extensive experience in creating precise and informative descriptions of cell types for ontologies. User Role: I need you to create definitions for specific cell types to be included in the Cell Ontology. Each definition should: 1. Avoid naming the cell type being defined directly. It should start with a statement of a general classification for the cell type being defined, followed by the characteristics that distinguish it from other cell types within the same general classification. 2. Describe distinguishing characteristics, including structural features, functional roles, and anatomical context. 3. Include species-specific information when relevant, noting presence or absence in different organisms. 4. Mention key molecular markers, transcription factors, or genes only if they are crucial for identification or development of the cell type. When including molecular markers, specify the species in which they have been identified (e.g., \"marker X in mice\", \"marker Y in humans\"). 5. For general cell types, focus on common features across different tissues or organs. 6. Include supporting references to key statements of the definition rather than listing them at the end. 7. Be concise yet comprehensive, aiming for 80-120 words in a single paragraph. 8. Use clear, scientific language accessible to biologists across various specialties. Example output for a specific cell type: \"A tuft cell that is part of the medullary epithelium of the thymus, characterized by lateral microvilli and specific markers, including L1CAM (1) in both mice and humans, as well as MHC II in mice (1,2). This cell is pivotal in immune functions such as antigen presentation, central tolerance, and type 2 immunity. It exhibits characteristics of both a medullary thymic epithelial cell (mTEC) and a peripheral tuft cell. Its development is governed by transcription factors such as POU2F3 (3,4).\" \"Please generate a definition for the following cell type: '[INSERT CELL TYPE HERE]'\" This standard prompt has been tested using Perplexity Free, PRO, and PRO R1, with all versions producing good results. PRO R1 provided the most detailed and informative definitions. 2. Refine the Definition \u00b6 Once the LLM generates a draft definition, follow these steps to refine the definition: Re-run the LLM prompt for improved output: If the intial output lacks details or references, repeat the query multiple times. This often increases the likelihood of generating a more comprehensive and accurate definition. For rare or harder-to-define cell types [EXAMPLE], consider modifying the prompt to provide additional context or specify key details. Remove redundant general information: Edit out details that apply broadly to all cell types within a classification (e.g., general functions, common morphological features such as \"description of tuft\" for tuft cells), as these should already be captured in the general class definition. Review references: Check the references provided by the LLM and ensure key statements in the definition have in-line text citations. Validate molecular marker specificity: Retain only markers that are specific to the defined cell type. Remove broadly expressed markers to avoid redundancy. Ensure species-specific molecular markers are correctly attributed. Example Output \u00b6 Cell Type Example: Intestinal Tuft cell \u00b6 First trial: Intestinal tuft cell perplexity query(1) Second trial: Intestinal tuft cell perplexity query(2) Refined defintion: \u00b6 A tuft cell that is part of the intestinal epithelium, characterized by a distinctive apical tuft and lateral cytospinules connecting to neighbouring cells. This cell senses luminal stimuli via taste receptors and succinate signalling, initiating type 2 immune responses through the secretion of interleukin-25 while modulating epithelial regeneration through prostaglandin synthesis. It expresses key molecular markers such as doublecortin-like kinase 1 (DCLK1) in mice (Hendel et al., 2022), and KIT proto-oncogene in humans (Huang et al., 2024). Developed from intestinal crypt stem cells, this cell requires transcription factor POU2F3 for its development.","title":"A Guide to Using LLm Prompts to Generate Textual Definitions in the Cell Ontology (CL)."},{"location":"LLM_prompt_guidelines_for_CL_definitions/#a-guide-to-using-llm-prompts-to-generate-textual-definitions-in-the-cell-ontology-cl","text":"This guide explains how to efficiently use an LLM prompt to generate CL textual definitions and outlines the steps to refine them to align with CL definition guidelines.","title":"A Guide to Using LLm Prompts to Generate Textual Definitions in the Cell Ontology (CL)."},{"location":"LLM_prompt_guidelines_for_CL_definitions/#1-generate-definitions-using-the-standard-prompt","text":"","title":"1. Generate Definitions Using the Standard Prompt"},{"location":"LLM_prompt_guidelines_for_CL_definitions/#standard-llm-prompt","text":"System Role: You are an expert cell biologist with extensive experience in creating precise and informative descriptions of cell types for ontologies. User Role: I need you to create definitions for specific cell types to be included in the Cell Ontology. Each definition should: 1. Avoid naming the cell type being defined directly. It should start with a statement of a general classification for the cell type being defined, followed by the characteristics that distinguish it from other cell types within the same general classification. 2. Describe distinguishing characteristics, including structural features, functional roles, and anatomical context. 3. Include species-specific information when relevant, noting presence or absence in different organisms. 4. Mention key molecular markers, transcription factors, or genes only if they are crucial for identification or development of the cell type. When including molecular markers, specify the species in which they have been identified (e.g., \"marker X in mice\", \"marker Y in humans\"). 5. For general cell types, focus on common features across different tissues or organs. 6. Include supporting references to key statements of the definition rather than listing them at the end. 7. Be concise yet comprehensive, aiming for 80-120 words in a single paragraph. 8. Use clear, scientific language accessible to biologists across various specialties. Example output for a specific cell type: \"A tuft cell that is part of the medullary epithelium of the thymus, characterized by lateral microvilli and specific markers, including L1CAM (1) in both mice and humans, as well as MHC II in mice (1,2). This cell is pivotal in immune functions such as antigen presentation, central tolerance, and type 2 immunity. It exhibits characteristics of both a medullary thymic epithelial cell (mTEC) and a peripheral tuft cell. Its development is governed by transcription factors such as POU2F3 (3,4).\" \"Please generate a definition for the following cell type: '[INSERT CELL TYPE HERE]'\" This standard prompt has been tested using Perplexity Free, PRO, and PRO R1, with all versions producing good results. PRO R1 provided the most detailed and informative definitions.","title":"Standard LLM Prompt"},{"location":"LLM_prompt_guidelines_for_CL_definitions/#2-refine-the-definition","text":"Once the LLM generates a draft definition, follow these steps to refine the definition: Re-run the LLM prompt for improved output: If the intial output lacks details or references, repeat the query multiple times. This often increases the likelihood of generating a more comprehensive and accurate definition. For rare or harder-to-define cell types [EXAMPLE], consider modifying the prompt to provide additional context or specify key details. Remove redundant general information: Edit out details that apply broadly to all cell types within a classification (e.g., general functions, common morphological features such as \"description of tuft\" for tuft cells), as these should already be captured in the general class definition. Review references: Check the references provided by the LLM and ensure key statements in the definition have in-line text citations. Validate molecular marker specificity: Retain only markers that are specific to the defined cell type. Remove broadly expressed markers to avoid redundancy. Ensure species-specific molecular markers are correctly attributed.","title":"2. Refine the Definition"},{"location":"LLM_prompt_guidelines_for_CL_definitions/#example-output","text":"","title":"Example Output"},{"location":"LLM_prompt_guidelines_for_CL_definitions/#cell-type-example-intestinal-tuft-cell","text":"First trial: Intestinal tuft cell perplexity query(1) Second trial: Intestinal tuft cell perplexity query(2)","title":"Cell Type Example: Intestinal Tuft cell"},{"location":"LLM_prompt_guidelines_for_CL_definitions/#refined-defintion","text":"A tuft cell that is part of the intestinal epithelium, characterized by a distinctive apical tuft and lateral cytospinules connecting to neighbouring cells. This cell senses luminal stimuli via taste receptors and succinate signalling, initiating type 2 immune responses through the secretion of interleukin-25 while modulating epithelial regeneration through prostaglandin synthesis. It expresses key molecular markers such as doublecortin-like kinase 1 (DCLK1) in mice (Hendel et al., 2022), and KIT proto-oncogene in humans (Huang et al., 2024). Developed from intestinal crypt stem cells, this cell requires transcription factor POU2F3 for its development.","title":"Refined defintion:"},{"location":"annotation_properties/","text":"Annotation Properties \u00b6 Note- this page is currently under development. The Cell Ontology has the following annotation properties: Annotation property Description Example term Example annotation Must have? Only one use per term is allowed? consider To be used on obsoleted classes, to point to a term that should be considered by curators for use in place of the obsoleted term. Multiple consider terms are allowed. It can be useful to combine this with a comment to indicate when replacement would be appropriate. CL:0000610 obsolete plant cell PO:0009002 No No created_by Added automatically on term creation with standard Protege settings. Ideally, this should use the \"supplied user name\" in the Protege User Details preference pane. This has been inconsistently applied in the past. CL:0002518 tmeehan Should Yes creation_date Added automatically on term creation with standard Protege settings. CL:0002518 2011-02-08T10:46:34Z Should Yes database_cross_reference Citable references that have helped generate the term and term's definition. Includes PubMed IDs (in the format PMID:XXXXXXXX). CL:0011005 GABAergic interneuron PMID:29724907 Should No dc:contributor Use this to annotate a whole ontology file with the identifier of a contributor. ORCID preferred. N/A https://orcid.org/0000-0001-9990-8331 Nice to have, if applicable No dc:creator Coming Soon CL:0001201 B cell, CD19-positive https://orcid.org/0000-0001-9990-8331 No Yes dc:date Coming soon CL:0001065 innate lymphoid cell 2017-01-30T20:20:48Z No Yes dc:description Use this to annotate a whole ontology file with a brief description of the ontology. N/A An ontology of cell types. No No dc:title Use this to annotate an ontology, giving it a human readable title. N/A Cell Ontology No No dcterms:license Use to attach a license to the whole ontology file. N/A http://creativecommons.org/licenses/by/4.0/ No No definition The textual definition for the ontology class. CL:0000946 antibody secreting cell A lymphocyte of B lineage that is devoted to secreting large amounts of immunoglobulin. Must Yes 'expand expression to' Coming soon Coming soon Coming soon No No foaf:depicted_by Use this to add a link to an image that depicts an example of an entity referred to by the term Coming soon Coming soon No No has_alternative_id In CL this is a legacy property. Do not use. CL:0000059 ameloblast CL:0000053 No No has_broad_synonym Used for synonyms where the primary definition accurately describes the synonym, but the definition of the synonym may encompass other structures as well. In some cases where a broad synonym is given, it will be a broad synonym for more than one ontology term. You are encouraged to add a reference that uses the term in this way. CL:0000365 animal zygote zygote No No has_exact_synonym Used for synonyms where the definition of the synonym is exactly the same as primary term definition. This is used when the same class can have more than one name. You are encouraged to add a reference that uses the term in this way. CL:0000622 acinar cell acinic cell Nice to have, if applicable No has_narrow_synonym Used for synonyms where the definition of the synonym is the same as the primary definition, but has additional qualifiers. You are encouraged to add a reference that uses the term in this way. CL:0000362 epidermal cell epithelial cell of skin No No has_obo_namespace This is a legacy annotation property. Do not add this manually. CL:0001061 abnormal cell cell No No has_related_synonym This scope is applied when a word of phrase has been used synonymously with the primary term name in the literature, but the usage is not strictly correct. That is, the synonym in fact has a slightly different meaning than the primary term name. Since users may not be aware that the synonym was being used incorrectly when searching for a term, related synonyms are included. CL:0000902 induced T-regulatory cell adaptive Treg No No has_synonym_type The target of this relation must be an annotation property of type 'synonym_type_property'. N/A N/A No No IAO_0000116 Coming soon Coming soon Coming soon No No id Automatically added by some pathways. Do not add manually. If duplicating a term (with the duplicate getting a new ID), it should be deleted. CL:2000074 splenocyte CL:2000074 Yes Yes in_subset Used to add subset tags, used in conjunction with subset_property CL:0000039 germ line cell _upper_level No No is_inferred This annotation property is used in some automated pipelines. Do not add manually Coming soon Coming soon No No rdfs:comment Use to add a clarifying comment to a term. This can be useful for adding examples and for clarifying terminological confusions. CL:0007016 adaxial cell In teleosts, adaxial cells give rise to slow muscle myoblasts. No Yes rdfs:isDefinedBy Do not add manually. Coming soon Coming soon No Yes rdfs:label Primary name - used as a display name by Protege (with standard settings) and most downstream consumers. Add only one of these. It must be unique within an ontology. CL:0000418 arcade cell arcade cell Must Yes RO_0002161 Coming soon Coming soon No No 'see also' Used to link to a webpage, such as a GitHub ticket. CL:0000134 mesenchymal stem cell https://github.com/obophenotype/cell-ontology/issues/474 No No shorthand Added automatically by some pipelines. Do not add manually Coming soon Coming soon No No subset_property A grouping class for subset tags. N/A N/A No No subset_property: added_for_HCA A subset tag for terms that were requested by the Human Cell Atlas. N/A N/A No No subset property: location_grouping A subset tag for cell types from a particular anatomical location. N/A N/A No No synonym_type_property A grouping class for synonym tags. N/A N/A No No 'term replaced by' To be used on obsolete terms to indicate a term that can be automatically substituted for the obsoleted term. Coming soon Coming soon No No","title":"CL annotation properties"},{"location":"annotation_properties/#annotation-properties","text":"Note- this page is currently under development. The Cell Ontology has the following annotation properties: Annotation property Description Example term Example annotation Must have? Only one use per term is allowed? consider To be used on obsoleted classes, to point to a term that should be considered by curators for use in place of the obsoleted term. Multiple consider terms are allowed. It can be useful to combine this with a comment to indicate when replacement would be appropriate. CL:0000610 obsolete plant cell PO:0009002 No No created_by Added automatically on term creation with standard Protege settings. Ideally, this should use the \"supplied user name\" in the Protege User Details preference pane. This has been inconsistently applied in the past. CL:0002518 tmeehan Should Yes creation_date Added automatically on term creation with standard Protege settings. CL:0002518 2011-02-08T10:46:34Z Should Yes database_cross_reference Citable references that have helped generate the term and term's definition. Includes PubMed IDs (in the format PMID:XXXXXXXX). CL:0011005 GABAergic interneuron PMID:29724907 Should No dc:contributor Use this to annotate a whole ontology file with the identifier of a contributor. ORCID preferred. N/A https://orcid.org/0000-0001-9990-8331 Nice to have, if applicable No dc:creator Coming Soon CL:0001201 B cell, CD19-positive https://orcid.org/0000-0001-9990-8331 No Yes dc:date Coming soon CL:0001065 innate lymphoid cell 2017-01-30T20:20:48Z No Yes dc:description Use this to annotate a whole ontology file with a brief description of the ontology. N/A An ontology of cell types. No No dc:title Use this to annotate an ontology, giving it a human readable title. N/A Cell Ontology No No dcterms:license Use to attach a license to the whole ontology file. N/A http://creativecommons.org/licenses/by/4.0/ No No definition The textual definition for the ontology class. CL:0000946 antibody secreting cell A lymphocyte of B lineage that is devoted to secreting large amounts of immunoglobulin. Must Yes 'expand expression to' Coming soon Coming soon Coming soon No No foaf:depicted_by Use this to add a link to an image that depicts an example of an entity referred to by the term Coming soon Coming soon No No has_alternative_id In CL this is a legacy property. Do not use. CL:0000059 ameloblast CL:0000053 No No has_broad_synonym Used for synonyms where the primary definition accurately describes the synonym, but the definition of the synonym may encompass other structures as well. In some cases where a broad synonym is given, it will be a broad synonym for more than one ontology term. You are encouraged to add a reference that uses the term in this way. CL:0000365 animal zygote zygote No No has_exact_synonym Used for synonyms where the definition of the synonym is exactly the same as primary term definition. This is used when the same class can have more than one name. You are encouraged to add a reference that uses the term in this way. CL:0000622 acinar cell acinic cell Nice to have, if applicable No has_narrow_synonym Used for synonyms where the definition of the synonym is the same as the primary definition, but has additional qualifiers. You are encouraged to add a reference that uses the term in this way. CL:0000362 epidermal cell epithelial cell of skin No No has_obo_namespace This is a legacy annotation property. Do not add this manually. CL:0001061 abnormal cell cell No No has_related_synonym This scope is applied when a word of phrase has been used synonymously with the primary term name in the literature, but the usage is not strictly correct. That is, the synonym in fact has a slightly different meaning than the primary term name. Since users may not be aware that the synonym was being used incorrectly when searching for a term, related synonyms are included. CL:0000902 induced T-regulatory cell adaptive Treg No No has_synonym_type The target of this relation must be an annotation property of type 'synonym_type_property'. N/A N/A No No IAO_0000116 Coming soon Coming soon Coming soon No No id Automatically added by some pathways. Do not add manually. If duplicating a term (with the duplicate getting a new ID), it should be deleted. CL:2000074 splenocyte CL:2000074 Yes Yes in_subset Used to add subset tags, used in conjunction with subset_property CL:0000039 germ line cell _upper_level No No is_inferred This annotation property is used in some automated pipelines. Do not add manually Coming soon Coming soon No No rdfs:comment Use to add a clarifying comment to a term. This can be useful for adding examples and for clarifying terminological confusions. CL:0007016 adaxial cell In teleosts, adaxial cells give rise to slow muscle myoblasts. No Yes rdfs:isDefinedBy Do not add manually. Coming soon Coming soon No Yes rdfs:label Primary name - used as a display name by Protege (with standard settings) and most downstream consumers. Add only one of these. It must be unique within an ontology. CL:0000418 arcade cell arcade cell Must Yes RO_0002161 Coming soon Coming soon No No 'see also' Used to link to a webpage, such as a GitHub ticket. CL:0000134 mesenchymal stem cell https://github.com/obophenotype/cell-ontology/issues/474 No No shorthand Added automatically by some pipelines. Do not add manually Coming soon Coming soon No No subset_property A grouping class for subset tags. N/A N/A No No subset_property: added_for_HCA A subset tag for terms that were requested by the Human Cell Atlas. N/A N/A No No subset property: location_grouping A subset tag for cell types from a particular anatomical location. N/A N/A No No synonym_type_property A grouping class for synonym tags. N/A N/A No No 'term replaced by' To be used on obsolete terms to indicate a term that can be automatically substituted for the obsoleted term. Coming soon Coming soon No No","title":"Annotation Properties"},{"location":"cite/","text":"How to cite CL \u00b6 The Cell Ontology 2016: enhanced content, modularization, and ontology interoperability. Alexander D Diehl, Terrence F Meehan, Yvonne M Bradford, Matthew H Brush, Wasila M Dahdul, David S Dougall, Yongqun He, David Osumi-Sutherland, Alan Ruttenberg, Sirarat Sarntivijai, Ceri E Van Slyke, Nicole A Vasilevsky, Melissa A Haendel, Judith A Blake, Christopher J Mungall. J Biomed Semantics. 2016 Jul 4;7(1):44. PMID:27377652, PMCID:PMC4932724, DOI:10.1186/s13326-016-0088-7 Logical development of the cell ontology. Terrence F Meehan, Anna Maria Masci, Amina Abdulla, Lindsay G Cowell, Judith A Blake, Christopher J Mungall, Alexander D Diehl. BMC Bioinformatics. 2011 Jan 5;12:6. PMID:21208450, PMCID:PMC3024222, DOI:10.1186/1471-2105-12-6 An ontology for cell types. Jonathan Bard, Seung Y Rhee, Michael Ashburner. Genome Biol. 2005;6(2):R21. PMID:15693950, PMCID:PMC551541, DOI:10.1186/gb-2005-6-2-r21","title":"Cite"},{"location":"cite/#how-to-cite-cl","text":"The Cell Ontology 2016: enhanced content, modularization, and ontology interoperability. Alexander D Diehl, Terrence F Meehan, Yvonne M Bradford, Matthew H Brush, Wasila M Dahdul, David S Dougall, Yongqun He, David Osumi-Sutherland, Alan Ruttenberg, Sirarat Sarntivijai, Ceri E Van Slyke, Nicole A Vasilevsky, Melissa A Haendel, Judith A Blake, Christopher J Mungall. J Biomed Semantics. 2016 Jul 4;7(1):44. PMID:27377652, PMCID:PMC4932724, DOI:10.1186/s13326-016-0088-7 Logical development of the cell ontology. Terrence F Meehan, Anna Maria Masci, Amina Abdulla, Lindsay G Cowell, Judith A Blake, Christopher J Mungall, Alexander D Diehl. BMC Bioinformatics. 2011 Jan 5;12:6. PMID:21208450, PMCID:PMC3024222, DOI:10.1186/1471-2105-12-6 An ontology for cell types. Jonathan Bard, Seung Y Rhee, Michael Ashburner. Genome Biol. 2005;6(2):R21. PMID:15693950, PMCID:PMC551541, DOI:10.1186/gb-2005-6-2-r21","title":"How to cite CL"},{"location":"cl-release/","text":"CL Release workflow \u00b6 While CL is an ODK ontology, it has a specific workflow for releases due to its large size and the limitations on standard GitHub releases. Requirements \u00b6 Aside from the standard requirements needed for ODK workflow, GH is required. Instructions on how to install GH can be found here You will need to log in to your GitHub account on GH before you can uses it. To do this, enter the following in your terminal: gh auth login You can then follow instructions below for web browser login (or use your prefer means of logging in). % gh auth login ? What account do you want to log into? GitHub.com ? What is your preferred protocol for Git operations? SSH ? Generate a new SSH key to add to your GitHub account? Yes ? Enter a passphrase for your new SSH key (Optional) ? Title for your SSH key: GitHub SSH ? How would you like to authenticate GitHub CLI? Login with a web browser ! First copy your one-time code: XXXX-XXXX Press Enter to open github.com in your browser... \u2713 Authentication complete. - gh config set -h github.com git_protocol ssh \u2713 Configured git protocol \u2713 Uploaded the SSH key to your GitHub account: /Users/username/.ssh/id_ed25519.pub \u2713 Logged in as username Release Process \u00b6 The release is done in two parts: 1. Refresh the imports and the components (CellxGene subset, HRA subset and slims) 1. Generate the release artefacts Preparation \u00b6 Ensure that all pull requests to be included in the release are merged Ensure that no other pull requests are merged during the release process Ensure you are on the master branch and have locally the latest changes from master ( git pull ) Ensure you have the latest ODK installed by running docker pull obolibrary/odkfull Navigate to the cell-ontology/src/ontology directory ( cd src/ontology ) Delete all temporary files (e.g., outdated plugins) by running sh run.sh make clean Refresh imports and components \u00b6 Checkout a new branch (e.g. git checkout -b refresh-imports-sept24 ) Run sh run.sh make refresh-imports Have a sanity check in the files Create a pull request and add at least a core editor as the reviewer Merge to main branch once reviewed and CI checks have passed Generate the release artefacts \u00b6 Ensure you are on the master branch and have locally the latest changes from master ( git pull ) Checkout a new branch (e.g. git checkout -b 20240904-release ) Run the release using sh run.sh make cl DEPLOY_GH=false . This will build all files and copy them to the correct place. Review the release as per the Review the release section in ODK-workflow release document Create a pull request and get a second set of eyes to review it. As CL uses a custom release pipeline, we ask that you get at least one core developer to review it too. Merge to main branch once reviewed and CI checks have passed Deploy release on GitHub by running make public_release GHVERSION=\"v2025-07-30\" on the release branch (DO NOTE CHANGE TO MAIN BRANCH!), replacing the date with the date of release (NOTE: no sh run.sh ) This should end with a GitHub release link that looks something like: https://github.com/obophenotype/cl/releases/tag/untagged-8935f3432525b27a0d84 . Copy the link and paste it in your browser, this should show you a draft release. Click the edit button (the pencil button on the top right corner) and change the tag to the GHVERSION you entered above (eg v2022-06-20) Change the TBD. in the main text to a summary of the main changes in the release if needed. Copy and paste the text and table from the reports/summary_release.md file. This file is in .gitignore and will only be available to those who have run the release. Scroll down all the way and click the update release button.","title":"CL release"},{"location":"cl-release/#cl-release-workflow","text":"While CL is an ODK ontology, it has a specific workflow for releases due to its large size and the limitations on standard GitHub releases.","title":"CL Release workflow"},{"location":"cl-release/#requirements","text":"Aside from the standard requirements needed for ODK workflow, GH is required. Instructions on how to install GH can be found here You will need to log in to your GitHub account on GH before you can uses it. To do this, enter the following in your terminal: gh auth login You can then follow instructions below for web browser login (or use your prefer means of logging in). % gh auth login ? What account do you want to log into? GitHub.com ? What is your preferred protocol for Git operations? SSH ? Generate a new SSH key to add to your GitHub account? Yes ? Enter a passphrase for your new SSH key (Optional) ? Title for your SSH key: GitHub SSH ? How would you like to authenticate GitHub CLI? Login with a web browser ! First copy your one-time code: XXXX-XXXX Press Enter to open github.com in your browser... \u2713 Authentication complete. - gh config set -h github.com git_protocol ssh \u2713 Configured git protocol \u2713 Uploaded the SSH key to your GitHub account: /Users/username/.ssh/id_ed25519.pub \u2713 Logged in as username","title":"Requirements"},{"location":"cl-release/#release-process","text":"The release is done in two parts: 1. Refresh the imports and the components (CellxGene subset, HRA subset and slims) 1. Generate the release artefacts","title":"Release Process"},{"location":"cl-release/#preparation","text":"Ensure that all pull requests to be included in the release are merged Ensure that no other pull requests are merged during the release process Ensure you are on the master branch and have locally the latest changes from master ( git pull ) Ensure you have the latest ODK installed by running docker pull obolibrary/odkfull Navigate to the cell-ontology/src/ontology directory ( cd src/ontology ) Delete all temporary files (e.g., outdated plugins) by running sh run.sh make clean","title":"Preparation"},{"location":"cl-release/#refresh-imports-and-components","text":"Checkout a new branch (e.g. git checkout -b refresh-imports-sept24 ) Run sh run.sh make refresh-imports Have a sanity check in the files Create a pull request and add at least a core editor as the reviewer Merge to main branch once reviewed and CI checks have passed","title":"Refresh imports and components"},{"location":"cl-release/#generate-the-release-artefacts","text":"Ensure you are on the master branch and have locally the latest changes from master ( git pull ) Checkout a new branch (e.g. git checkout -b 20240904-release ) Run the release using sh run.sh make cl DEPLOY_GH=false . This will build all files and copy them to the correct place. Review the release as per the Review the release section in ODK-workflow release document Create a pull request and get a second set of eyes to review it. As CL uses a custom release pipeline, we ask that you get at least one core developer to review it too. Merge to main branch once reviewed and CI checks have passed Deploy release on GitHub by running make public_release GHVERSION=\"v2025-07-30\" on the release branch (DO NOTE CHANGE TO MAIN BRANCH!), replacing the date with the date of release (NOTE: no sh run.sh ) This should end with a GitHub release link that looks something like: https://github.com/obophenotype/cl/releases/tag/untagged-8935f3432525b27a0d84 . Copy the link and paste it in your browser, this should show you a draft release. Click the edit button (the pencil button on the top right corner) and change the tag to the GHVERSION you entered above (eg v2022-06-20) Change the TBD. in the main text to a summary of the main changes in the release if needed. Copy and paste the text and table from the reports/summary_release.md file. This file is in .gitignore and will only be available to those who have run the release. Scroll down all the way and click the update release button.","title":"Generate the release artefacts"},{"location":"contact_us/","text":"Contact Us \u00b6 GitHub \u00b6 The preferred point of contact for the Cell Ontology is the GitHub Issue Tracker . It is used commonly for requesting new terms or suggesting changes to existing terms. Feel free to open a new issue with any kind of request/question/consideration you might have. If you do not have a GitHub account, you can sign up for a free account here . E-mail and other contacts \u00b6 The Cell Ontology also has a Slack Channel and monthly meetings, with an open agenda . If you want to join the channel or talk about any other topics related to the Cell Ontology, you may reach out to one of the active CL editors. The official contact for CL listed at the OBO Foundry is Alexander Diehl , but feel free to contact any other individual. A list of active CL editors can be found here . Note that requests on the GitHub issue tracker may be addressed more quickly, as individuals are often busy. For other details on CL, you may see http://obofoundry.org/ontology/cl.html .","title":"Contact"},{"location":"contact_us/#contact-us","text":"","title":"Contact Us"},{"location":"contact_us/#github","text":"The preferred point of contact for the Cell Ontology is the GitHub Issue Tracker . It is used commonly for requesting new terms or suggesting changes to existing terms. Feel free to open a new issue with any kind of request/question/consideration you might have. If you do not have a GitHub account, you can sign up for a free account here .","title":"GitHub"},{"location":"contact_us/#e-mail-and-other-contacts","text":"The Cell Ontology also has a Slack Channel and monthly meetings, with an open agenda . If you want to join the channel or talk about any other topics related to the Cell Ontology, you may reach out to one of the active CL editors. The official contact for CL listed at the OBO Foundry is Alexander Diehl , but feel free to contact any other individual. A list of active CL editors can be found here . Note that requests on the GitHub issue tracker may be addressed more quickly, as individuals are often busy. For other details on CL, you may see http://obofoundry.org/ontology/cl.html .","title":"E-mail and other contacts"},{"location":"contributing/","text":"How to contribute to CL \u00b6 We welcome your contributions to CL! Generally, you can follow the editors workflow instructions here . However, if you aren't confident in directly editing the ontology, you can contribute by writing up an issue and one of our curators/developers will pick it up and address it. Writing up an issue \u00b6 If you want a new term added, or want edits to a current term, or spot any mistakes/issues with CL, or you have any other CL related issues, you can write up a ticket using the following steps: Go to the issues tab in CL. Click the 'New issue' tab on the top right corner and select the most appropriate category for your issue. (Note: blank issues can be created if none of the categories fit, but we recommend using the categories as they are designed to be more comprehensive). Fill up the form as best you can, giving a descriptive title to your issue name and leaving the bracketed [] tag in the title: eg. Add new term is bad name, while [NTR] larval stage X is good name. When writing up more complex issues that include multiple items or steps, make sure you include the use of - [ ] to denote action items. These turn into checkboxes which makes it much faster to assess which comments have been addressed. (Note: it is better to write up multiple issues than one big one with multiple items, e.g. write up one issue for each term you want added rather than an issue with all the terms you want added.) If you know a specific curator/editor that you want handling your ticket, you can assign them to your ticket in the assignee tab on the right, if not, someone from our team will assign an appropriate person to handle your ticket. If, however, your ticket has not been looked at in more than 10 days, and you suspect that it might have been missed, please assign it to gouttegd and they will assign it appropriately. If you know how to edit the ontology directly, please then proceed to making a Pull request with the guidelines below, following the editors workflow instructions here . Pull request guidelines \u00b6 Give your pull requests good names: Add new terms is bad. Adding larval stage X term #332 is ok. Make sure pull requests have someone assigned to review them and remind them once in a while. Do not let them go dormant Assign yourself to be the Assignee Make sure to use - [ ] to denote action items in issues and pull requests, not just comments. These turn into checkboxes which makes it much faster to assess which comments have been addressed and can be ignored. Give a short summary of the pull request - that way we can find suitable reviewers much quicker. Say which terms you are adding or what kinds of changes you are proposing. It is most of the time a good idea to use squash merge rather than merge for your pull request, to keep the git history short and useful. Pull requests that require imports to be refreshed \u00b6 If your pull request references foreign terms from an external ontology that are not yet present in the import module for that ontology (for example, you\u2019re adding a logical definition that makes use of a GO term for the first time), imports needs to be refreshed for the foreign terms to be available to use. If you have the technical skills and/or the required computer resources (refreshing imports can be a memory-intensive task), you may refresh the imports yourself before submitting the pull request, by following the appropriate procedure . If you can\u2019t apply the imports refreshing procedure for any reason, you may instead opt for using \u201cbare IRIs\u201d when editing the ontology, everywhere you need a reference to a foreign term. Then, when submitting your pull request, label it with the tag update-imports-required to ask that a member of the tech support group refresh the imports before the pull request can be merged. People reviewing pull requests must 1) make sure that if a pull request is referencing bare IRIs, the request is tagged with update-imports-required (adding the label themselves if needed); and 2) make sure that imports have indeed been updated (either by the author of the pull request, or by someone from the tech support group if requested) before allowing the request to be merged.","title":"Contributing"},{"location":"contributing/#how-to-contribute-to-cl","text":"We welcome your contributions to CL! Generally, you can follow the editors workflow instructions here . However, if you aren't confident in directly editing the ontology, you can contribute by writing up an issue and one of our curators/developers will pick it up and address it.","title":"How to contribute to CL"},{"location":"contributing/#writing-up-an-issue","text":"If you want a new term added, or want edits to a current term, or spot any mistakes/issues with CL, or you have any other CL related issues, you can write up a ticket using the following steps: Go to the issues tab in CL. Click the 'New issue' tab on the top right corner and select the most appropriate category for your issue. (Note: blank issues can be created if none of the categories fit, but we recommend using the categories as they are designed to be more comprehensive). Fill up the form as best you can, giving a descriptive title to your issue name and leaving the bracketed [] tag in the title: eg. Add new term is bad name, while [NTR] larval stage X is good name. When writing up more complex issues that include multiple items or steps, make sure you include the use of - [ ] to denote action items. These turn into checkboxes which makes it much faster to assess which comments have been addressed. (Note: it is better to write up multiple issues than one big one with multiple items, e.g. write up one issue for each term you want added rather than an issue with all the terms you want added.) If you know a specific curator/editor that you want handling your ticket, you can assign them to your ticket in the assignee tab on the right, if not, someone from our team will assign an appropriate person to handle your ticket. If, however, your ticket has not been looked at in more than 10 days, and you suspect that it might have been missed, please assign it to gouttegd and they will assign it appropriately. If you know how to edit the ontology directly, please then proceed to making a Pull request with the guidelines below, following the editors workflow instructions here .","title":"Writing up an issue"},{"location":"contributing/#pull-request-guidelines","text":"Give your pull requests good names: Add new terms is bad. Adding larval stage X term #332 is ok. Make sure pull requests have someone assigned to review them and remind them once in a while. Do not let them go dormant Assign yourself to be the Assignee Make sure to use - [ ] to denote action items in issues and pull requests, not just comments. These turn into checkboxes which makes it much faster to assess which comments have been addressed and can be ignored. Give a short summary of the pull request - that way we can find suitable reviewers much quicker. Say which terms you are adding or what kinds of changes you are proposing. It is most of the time a good idea to use squash merge rather than merge for your pull request, to keep the git history short and useful.","title":"Pull request guidelines"},{"location":"contributing/#pull-requests-that-require-imports-to-be-refreshed","text":"If your pull request references foreign terms from an external ontology that are not yet present in the import module for that ontology (for example, you\u2019re adding a logical definition that makes use of a GO term for the first time), imports needs to be refreshed for the foreign terms to be available to use. If you have the technical skills and/or the required computer resources (refreshing imports can be a memory-intensive task), you may refresh the imports yourself before submitting the pull request, by following the appropriate procedure . If you can\u2019t apply the imports refreshing procedure for any reason, you may instead opt for using \u201cbare IRIs\u201d when editing the ontology, everywhere you need a reference to a foreign term. Then, when submitting your pull request, label it with the tag update-imports-required to ask that a member of the tech support group refresh the imports before the pull request can be merged. People reviewing pull requests must 1) make sure that if a pull request is referencing bare IRIs, the request is tagged with update-imports-required (adding the label themselves if needed); and 2) make sure that imports have indeed been updated (either by the author of the pull request, or by someone from the tech support group if requested) before allowing the request to be merged.","title":"Pull requests that require imports to be refreshed"},{"location":"editing_guidelines/","text":"Guidelines for CL editors \u00b6 Naming terms \u00b6 General rules \u00b6 All labels should be singular nouns. Words should not be capitalized, unless they are proper names or are capitalized as a standard (e.g., \u201cPeyer's\u201d and \u201cB\u201d in \u201cPeyer's patch B cell\u201d). Avoid special characters: use only alphanumeric characters, space, dash ( - ), slash ( / ), and apostrophe ( ' ). Advice on writing labels \u00b6 Bear in mind that users will often encounter terms in isolation. Sufficiently descriptive labels are therefore recommended, especially where there is obvious potential for confusion. For example, the label 'peripheral nervous system neuron' is preferred over 'peripheral neuron' as the former has more clarity. For classes that refer to cell types in specific anatomical structures, the label may have the adjectival or noun form of the anatomical structure, for example, 'hepatic oval stem cell' or 'liver dendritic cell' (\"hepatic\" vs. \"liver\"). To determine which form of the anatomical term to use, it is recommended for the editor to search PubMed/review literature to determine common usage. If there is no clear preference, the editor can defer to use the adjectival form and add the noun form as an exact synonym. Try to maintain consistent patterns of naming where possible. However, it may make sense to override this in order to conform to common usage. Defining terms \u00b6 This section is about the textual definition of terms. Logically consistent classification is important, but an ontology is only useful (and maintainable) if all humans that interact with it (users, curators and editors) can quickly find the terms they need and understand what they refer to. This requires clear, unambiguous, human-readable definitions. When crafting a definition, editors should aim for a reasonably succinct statement about the class allowing curators and users to easily distinguish it from other, similar classes, and which captures key points of interest about that class. It should capture assertions made in the formal part of the definition (the relationships) as closely as possible without becoming stilted and difficult to read. The basic structure of a definition should be as follows: A genus that diff1 and diff2 . It also diff3 and gloss ... where genus is a general classification and diff1 , diff2 , etc. are the differentia , which state what differentiates this class from others that share the same general classification. The gloss, when present, gives some key points of interest about the class. The first sentence of the definition should refer to the definiendum in singular form. The rest of the definition may then invoke the plural form. Contents of definitions \u00b6 It is difficult to specify, a priori , which assertions should be included in a textual definition. However there are some general guidelines. DO make sure your definition is consistent with the definition of the superclass(es). DO make sure your definition includes the information that is recorded in all the direct formal relationships to the class. AVOID assertions about structures or cell types that are not part of the cell type being described, except when they pertain to some direct relationships with the cell type being described. AVOID including details that could better be included in the definition of subtypes of the cell type being described. LIMIT information that applies to only some members of the class. This should only be used sparingly; when used, it should be made clear that it does not apply to all members of the class. AVOID using gene expression as the differentium. AVOID extensive repetition of assertions made in superclass definitions, unless these assertions are used to provide direct evidence for class membership. DO NOT add informations about what happens in mutant or pathological states backgrounds or other kinds of non-control conditions. DO NOT include reasons for believing the assertions to be true. These should be recorded in comments. DO NOT raise questions in the definition. The definition should have the sense of being definitive, which is undermined if we show doubt. Any doubt should be recorded in comments instead. Comments \u00b6 Comments should be used for: Providing evidence. In some cases it is useful to know the type of evidence for an assertion. This should not be recorded in the definition, but can be recorded in a comment. Disambiguation. Sometimes a single term is used in the literature with multiple meanings. In such cases, a comment should be added outlining these different uses and how they relate to the definition set in the ontology. Reporting editorial decisions (or decisions in waiting) about the term. This includes providing a reason for obsoleting a term, or letting users and curators know that the term may be merged or split in the future, e.g., when enough evidence for the merge/split will be available. Try to be consistent in how you phrase the various types of comments. For example: when giving a reason for obsoletion, use \u201cObsoleted as ...\u201d; when indicating a potential future merge, use \u201cPossible equivalence with {other term} ...\u201d. Synonyms \u00b6 Extensive addition of synonyms helps \u201cfindability\u201d of terms when search. Synonyms can and should be added liberally. Of note, the intention of the ontology is not meant to record how a synonym is used in all specific sources in which it appears. Rather an editor, after doing due diligence in researching the terms/synonyms, must determine how a term is used at the present moment in the scientific community. Guidelines on the type of synonyms: DO use has_exact_synonym only when the label and the synonym can be used interchangeably without dispute and refer to the same concept. Example: the terms \u201cleukocyte\u201d, \u201cleucocyte\u201d (spelling variation\u201d) and \u201cwhite blood cell\u201d (layman\u2019s term) all refer to the exact same concept (a specific cell type) and would be considered exact synonyms. Terms that may refer to more than one concept, especially within the biomedical domain, should NOT be annotated as exact synonyms, including abbreviations. A synonym that is an abbreviation should be annotated using has_related_synonym and with property type \u201cabbreviation\u201d (technically: the synonym annotation assertion axiom should itself be annotated with a http://www.geneontology.org/formats/oboInOwl#hasSynonymType property with value http://purl.obolibrary.org/obo/OMO_0003000 ). Example: \u201cWBC\u201d can stand for \u201cwhite blood cell\u201d and refer to \u201cleukocyte\u201d, but within the biomedical domain it can also represent \u201cwhite blood cell count\u201d or, perhaps less frequently, \u201cwhole-body counting\u201d, two distinct concepts with separate OBO ontology terms. DO check that exact synonyms are unique across the ontology. In other words, if class A has synonym \u201cX\u201d, \u201cX\u201d should NOT be an exact synonym for any other CL term. DO be mindful of the \u201cdirectionality\u201d of the narrow and broad types of synonyms. They qualify the synonym , not the original term. Example: asserting that \u201cperipheral blood mononuclear cell\u201d is a narrow synonym of \u201cmononuclear cell\u201d means that \u201cperipheral blood mononuclear cell\u201c refers to a narrower (more specific) concept than \u201cmononuclear cell\u201d, not the other way around. DO use has_related_synonym where the overlap between the synonym and the term label may be uncler, disputable or not true in all scenarios or contexts, but do want the term to be findable when using the synonym as a search string. This includes abbreviations, which should be annotated as related synonyms with synonym type \u201cabbreviation\u201d (see point 2 above). If a synonym includes a mix of abbreviations and words, DO use has_related_synonym EXCEPT when there is enough context within the synonym itself to make it clear that the synonym refers only to the concept being annotated. Example: \u201clung TRM CD8-positive, CD103-positive cell\u201d should be an exact synonym of \u201clung resident memory CD8-positive, CD103-positive, alpha-beta T cell\u201d, even though \u201cTRM\u201d (in this case) is an abbreviation for \u201ctissue resident T cell\u201d. Note that without this context \u201cTRM\u201d should NOT be considered an exact synonym for \u201ctissue resident T cell\u201d as \u201cTRM\u201d could also mean \u201ctreatment-related mortality\u201d, another OBO ontology concept. Compare the previous example to \u201cIMB cell\u201d, which should be a related synonym of \u201cinvaginating midget bipolar cell\u201d, as there is not enough context to confidently infer what \"IMB\" stands for. Considerations on style \u00b6 The following considerations apply both to all human-readable fields (names, textual definitions, comments, synonyms). United States (US) English or British English? Where there are differences in the accepted spelling between British and US English, use the US form. British English variants of the labels may be added as synonyms (e.g., a term labelled \u201cepithelial cell of esophagus\u201d may have \u201cepithelial cell of oesophagus\u201d as an exact synonym). Use of jargon. The aim of the ontology is to provide useable descriptions and links to the reader. Consequently, try to avoid obscure jargon or pretentious Latin/Greek, especially where widely understood, plain alternatives exist. Where it will aid searching, such terms may be added to synonyms and/or as asides in the \u201cgloss\u201d part of definitions. That or which? These are so interchangeable that there isn\u2019t really a rule anymore. But as a guideline, use \u201cwhich\u201d after a comma (e.g., \u201cthis study, which cost $10,000, was a success\u201d), and \u201cthat\u201d when no comma is used (e.g., \u201cthe study that cost $10,000 was a success\u201d). Use of hyphens. Yes to those that help clarity (e.g., \u201cposterior-most\u201d) and those that are regularly used/accepted in the literature. Generally, no hyphens after prefixes such as \u201csub\u201d, \u201cmid\u201d, \u201csemi\u201d, \u201chemi\u201d, etc. (e.g., \u201chemidesmosome\u201d instead of \u201chemi-desmosome\u201d), unless it helps with clarity (e.g., \u201cmulti-innervated\u201d). No hyphens for composed location adjectives (e.g., \u201cposteroanterior\u201d), unless there are more than two compounds (e.g., \u201cventro-posterolateral\u201d). Abbreviations. Avoid abbreviations, contractions, and symbols born out of laziness, such as & , + , or vs for \u201cversus\u201d. Avoid abbreviations unless they are self-explanatory, commonly understood, or they really do help to reduce the amount of typing enough to enhance readability. Use full chemical element names, not symbols (e.g., \u201chydrogen\u201d instead of \u201cH+\u201d, \u201ccopper\u201d instead of \u201cCu\u201d, etc.). For biomolecules, spell out the term wherever practical (e.g., \u201cfibroblast growth factor\u201d instead of \u201cFGF\u201d). Abbreviations are acceptable in synonyms, in cases where the abbreviation is the synonym. Cross-references to the literature \u00b6 Assertions in textual definitions, evidence provided in comments, and synonyms should be backed up by citing the appropriate literature. Citations are made by cross-references, that is by adding http://www.geneontology.org/formats/oboInOwl#hasDbXref annotations to the definition, comment, and synonym annotations. Add one such annotation per reference, using the CURIE syntax with well-known prefixes: PMID:1234567 for a PubMed identifier; doi:xx.yyyy/... for a DOI; ISBN:... for a ISBN. If the main source for an assertion is a term in another ontology, the short identifier for that term may be used as a cross-reference. For example, WBbt:0006799 to cross-reference a term in the C. elegans Gross Anatomy Ontology. If using a MeSH (Medical Subject Heading) term as a cross-reference, add the database_cross_reference annotation using the MeSH Unique ID, NOT MeSH Tree Number. For example, a database_cross_reference can be MESH:D004759, NOT MESH:A03.492.766.440.250. ORCID identifiers may also be used when the only available source for an assertion is an individual researcher. However, this should be AVOIDED. Technical details of adding a cross-reference using Prot\u00e9g\u00e9 : For CURIEs, ORCIDs: In the \"Create Annotation\" window, select the annotation property database_cross_reference . For adding URLs to text definitions or synonyms: In the \"Create Annotation\" window, select the annotation property database_cross_reference . For adding URLs to axioms that are NOT text definitions or synonyms: In the \"Create Annotation\" window, select the annotation property source . For CURIEs: Enter the CURIE, using the bioregistry OBO context prefix ( link to prefixmap ), as a Value on the \"Literal\" tab. Leave Datatype empty. In cases where more than one CURIE is available for a resource, either is acceptable, but using the more semantically specific identifier is recommended. For example, when both a PMID and a doi are available for a resource, using the PMID is recommended since it indicates the cross-reference points to a paper, as opposed to a doi which could point to any digital object. For ORCIDs: Enter the ORCID as an IRI in the IRI field on the \"IRI Editor\" tab, for example https://orcid.org/0000-0002-7356-1779 . For URLs: Enter the URL as a literal string with Datatype xsd:anyURI selected. To restate, in all cases above except ORCIDs, the values are entered as literal strings. An ORCID MUST BE entered as an IRI. Term contributors \u00b6 When adding an ORCID to identify a term contributor, in the \"Create Annotation\" window, select the annotation property dcterms:contributor . The ORCID is still entered as an IRI on the \u201cIRI Editor\u201d tab. Formal definitions \u00b6 The formal definition of a class is made up of all the logical axioms about the class (as opposed to the annotation assertion axioms). This includes classification assertions, relationship assertions, equivalence assertions, and disjointness assertions. Note: In OWL formalism, both classification and relationship assertions are represented using SubClassOf axioms. However, in this document, we make a strict distinction between a classification (where a class is a subclass of a named class ), and a relationship (where a class is a subclass of an anonymous class expression ). For example, in the formal definition of CL:0000392 (\u201ccrystal cell\u201d): Class: 'crystal cell' SubClassOf: 'hemocyte' SubClassOf: 'develops from' some 'procrystal cell' The first SubClassOf axiom denotes an actual classification, whereas the second denotes a relationship. Asserting classification \u00b6 In order to keep the ontology maintainable, asserted classifications should be limited where possible. Ideally, all terms would have only a single asserted parent (also known as \u201csuperclass\u201d). Given the presence of suitable logically defined classes (see below) and sufficient relationships for the term you are making, additional classification can be inferred automatically by reasoning. However, as we are limited in what types of classification we are able to infer, you may need to assert multiple parents. Two asserted classifications are plainly acceptable. If you must assert three or more classifications, then you should make a note with a suggestion for which of the asserted classifications are good candidates for formalisation and inferred classification. Logically defined classes \u00b6 Logically defined classes are terms that have formal definitions that specify complete necessary and sufficient conditions for membership of the class. They can be used by a reasoner to auto-classify the ontology by searching for terms that fulfill these conditions. Logically defined classes are variously referred to as \u201ccross-products\u201d (XPs), \u201cgenus and differentia definitions\u201d, \u201cequivalent classes\u201d, or \u201cintersections\u201d. In OWL formalism, they are represented using EquivalentClasses axioms. Generally, logical definitions follow the structure: \u201cAny X that REL some Y [and REL some Z ...]\u201d, where X is the genus and each following clause (\u201cthat REL some Y \u201d) is a differentium. Strictly speaking, logical definitions can be arbitrarily complex. It is recommended, however, to stick as much as possible to \u201csimple\u201d logical definitions following the structure above. More complex definitions are harder to understand, and may involve OWL constructs that are legal but not fully supported by the available reasoners. Good candidates for logically defined classes include classes whose only differentium is: what the cell is part of; what it innervates (or, if more precisely known, what its axon(s) or dendrite(s) innervate); its function. Care must be taken not to use logically defined classes too liberally. You should be satisfied that all automatic classifications that result would make sense (or at least be justifiable) to a biologist and would cover most cases of usages with as few edge cases as possible. If you are unsure whether a characteristic of a cell should be expressed as a relationship or as a differentium in a logically defined class: use a relationship. The textual definition of a logically defined class should be a plain English equivalent of the logical definition. However, in some cases it can be useful to add more details in the \u201cgloss\u201d part when relevant. Asserting relationships \u00b6 Please refer to the relations guide for detailled guidelines about which relations to use for most cases. Design Pattern Usage with DOSDP \u00b6 The cell ontology contains a large number of terms, classifications, and relationships that are constantly expanding. Manually maintaining all these elements would be a daunting task, so a substantial portion of the maintenance is automated. This automation heavily relies on the systematic use of design patterns. CL uses Dead simple OWL design patterns (DOSDP, Osumi-Sutherland et al. , 2017 ) to document simple patterns, as they require minimal programming expertise, and once implemented, it is easy to edit. All patterns are stored in /src/patterns/dosdp-patterns , while the editable tables are located in /src/patterns/data/default . Cycling cell states \u00b6 Pattern name: cyclingCellStates.yaml Cell cycling is a fundamental biological mechanism that brings a cell to divide and duplicate into two daughter cells. This process is carried out by a large number of cells, and cells undergoing cell cycling have a distinct transcriptional profile compared to non cycling cells. Cycling cells need to be annotated and described by CL terms as these cells have been identified in a multitude of single-cell transcriptional datasets. The terms created with this pattern are labeled as 'cycling X' , being X the parent term, and have an exact synonym 'proliferating X' . These cell terms can be logically defined as a 'cell' and 'participates in' some 'cell cycle process' and 'has quality' some 'active' . Ex: 'cycling B cell' SubClassOf 'B cell and 'participates in' some 'cell cycle process' and 'has quality' some 'active'","title":"Guidelines for CL editors"},{"location":"editing_guidelines/#guidelines-for-cl-editors","text":"","title":"Guidelines for CL editors"},{"location":"editing_guidelines/#naming-terms","text":"","title":"Naming terms"},{"location":"editing_guidelines/#general-rules","text":"All labels should be singular nouns. Words should not be capitalized, unless they are proper names or are capitalized as a standard (e.g., \u201cPeyer's\u201d and \u201cB\u201d in \u201cPeyer's patch B cell\u201d). Avoid special characters: use only alphanumeric characters, space, dash ( - ), slash ( / ), and apostrophe ( ' ).","title":"General rules"},{"location":"editing_guidelines/#advice-on-writing-labels","text":"Bear in mind that users will often encounter terms in isolation. Sufficiently descriptive labels are therefore recommended, especially where there is obvious potential for confusion. For example, the label 'peripheral nervous system neuron' is preferred over 'peripheral neuron' as the former has more clarity. For classes that refer to cell types in specific anatomical structures, the label may have the adjectival or noun form of the anatomical structure, for example, 'hepatic oval stem cell' or 'liver dendritic cell' (\"hepatic\" vs. \"liver\"). To determine which form of the anatomical term to use, it is recommended for the editor to search PubMed/review literature to determine common usage. If there is no clear preference, the editor can defer to use the adjectival form and add the noun form as an exact synonym. Try to maintain consistent patterns of naming where possible. However, it may make sense to override this in order to conform to common usage.","title":"Advice on writing labels"},{"location":"editing_guidelines/#defining-terms","text":"This section is about the textual definition of terms. Logically consistent classification is important, but an ontology is only useful (and maintainable) if all humans that interact with it (users, curators and editors) can quickly find the terms they need and understand what they refer to. This requires clear, unambiguous, human-readable definitions. When crafting a definition, editors should aim for a reasonably succinct statement about the class allowing curators and users to easily distinguish it from other, similar classes, and which captures key points of interest about that class. It should capture assertions made in the formal part of the definition (the relationships) as closely as possible without becoming stilted and difficult to read. The basic structure of a definition should be as follows: A genus that diff1 and diff2 . It also diff3 and gloss ... where genus is a general classification and diff1 , diff2 , etc. are the differentia , which state what differentiates this class from others that share the same general classification. The gloss, when present, gives some key points of interest about the class. The first sentence of the definition should refer to the definiendum in singular form. The rest of the definition may then invoke the plural form.","title":"Defining terms"},{"location":"editing_guidelines/#contents-of-definitions","text":"It is difficult to specify, a priori , which assertions should be included in a textual definition. However there are some general guidelines. DO make sure your definition is consistent with the definition of the superclass(es). DO make sure your definition includes the information that is recorded in all the direct formal relationships to the class. AVOID assertions about structures or cell types that are not part of the cell type being described, except when they pertain to some direct relationships with the cell type being described. AVOID including details that could better be included in the definition of subtypes of the cell type being described. LIMIT information that applies to only some members of the class. This should only be used sparingly; when used, it should be made clear that it does not apply to all members of the class. AVOID using gene expression as the differentium. AVOID extensive repetition of assertions made in superclass definitions, unless these assertions are used to provide direct evidence for class membership. DO NOT add informations about what happens in mutant or pathological states backgrounds or other kinds of non-control conditions. DO NOT include reasons for believing the assertions to be true. These should be recorded in comments. DO NOT raise questions in the definition. The definition should have the sense of being definitive, which is undermined if we show doubt. Any doubt should be recorded in comments instead.","title":"Contents of definitions"},{"location":"editing_guidelines/#comments","text":"Comments should be used for: Providing evidence. In some cases it is useful to know the type of evidence for an assertion. This should not be recorded in the definition, but can be recorded in a comment. Disambiguation. Sometimes a single term is used in the literature with multiple meanings. In such cases, a comment should be added outlining these different uses and how they relate to the definition set in the ontology. Reporting editorial decisions (or decisions in waiting) about the term. This includes providing a reason for obsoleting a term, or letting users and curators know that the term may be merged or split in the future, e.g., when enough evidence for the merge/split will be available. Try to be consistent in how you phrase the various types of comments. For example: when giving a reason for obsoletion, use \u201cObsoleted as ...\u201d; when indicating a potential future merge, use \u201cPossible equivalence with {other term} ...\u201d.","title":"Comments"},{"location":"editing_guidelines/#synonyms","text":"Extensive addition of synonyms helps \u201cfindability\u201d of terms when search. Synonyms can and should be added liberally. Of note, the intention of the ontology is not meant to record how a synonym is used in all specific sources in which it appears. Rather an editor, after doing due diligence in researching the terms/synonyms, must determine how a term is used at the present moment in the scientific community. Guidelines on the type of synonyms: DO use has_exact_synonym only when the label and the synonym can be used interchangeably without dispute and refer to the same concept. Example: the terms \u201cleukocyte\u201d, \u201cleucocyte\u201d (spelling variation\u201d) and \u201cwhite blood cell\u201d (layman\u2019s term) all refer to the exact same concept (a specific cell type) and would be considered exact synonyms. Terms that may refer to more than one concept, especially within the biomedical domain, should NOT be annotated as exact synonyms, including abbreviations. A synonym that is an abbreviation should be annotated using has_related_synonym and with property type \u201cabbreviation\u201d (technically: the synonym annotation assertion axiom should itself be annotated with a http://www.geneontology.org/formats/oboInOwl#hasSynonymType property with value http://purl.obolibrary.org/obo/OMO_0003000 ). Example: \u201cWBC\u201d can stand for \u201cwhite blood cell\u201d and refer to \u201cleukocyte\u201d, but within the biomedical domain it can also represent \u201cwhite blood cell count\u201d or, perhaps less frequently, \u201cwhole-body counting\u201d, two distinct concepts with separate OBO ontology terms. DO check that exact synonyms are unique across the ontology. In other words, if class A has synonym \u201cX\u201d, \u201cX\u201d should NOT be an exact synonym for any other CL term. DO be mindful of the \u201cdirectionality\u201d of the narrow and broad types of synonyms. They qualify the synonym , not the original term. Example: asserting that \u201cperipheral blood mononuclear cell\u201d is a narrow synonym of \u201cmononuclear cell\u201d means that \u201cperipheral blood mononuclear cell\u201c refers to a narrower (more specific) concept than \u201cmononuclear cell\u201d, not the other way around. DO use has_related_synonym where the overlap between the synonym and the term label may be uncler, disputable or not true in all scenarios or contexts, but do want the term to be findable when using the synonym as a search string. This includes abbreviations, which should be annotated as related synonyms with synonym type \u201cabbreviation\u201d (see point 2 above). If a synonym includes a mix of abbreviations and words, DO use has_related_synonym EXCEPT when there is enough context within the synonym itself to make it clear that the synonym refers only to the concept being annotated. Example: \u201clung TRM CD8-positive, CD103-positive cell\u201d should be an exact synonym of \u201clung resident memory CD8-positive, CD103-positive, alpha-beta T cell\u201d, even though \u201cTRM\u201d (in this case) is an abbreviation for \u201ctissue resident T cell\u201d. Note that without this context \u201cTRM\u201d should NOT be considered an exact synonym for \u201ctissue resident T cell\u201d as \u201cTRM\u201d could also mean \u201ctreatment-related mortality\u201d, another OBO ontology concept. Compare the previous example to \u201cIMB cell\u201d, which should be a related synonym of \u201cinvaginating midget bipolar cell\u201d, as there is not enough context to confidently infer what \"IMB\" stands for.","title":"Synonyms"},{"location":"editing_guidelines/#considerations-on-style","text":"The following considerations apply both to all human-readable fields (names, textual definitions, comments, synonyms). United States (US) English or British English? Where there are differences in the accepted spelling between British and US English, use the US form. British English variants of the labels may be added as synonyms (e.g., a term labelled \u201cepithelial cell of esophagus\u201d may have \u201cepithelial cell of oesophagus\u201d as an exact synonym). Use of jargon. The aim of the ontology is to provide useable descriptions and links to the reader. Consequently, try to avoid obscure jargon or pretentious Latin/Greek, especially where widely understood, plain alternatives exist. Where it will aid searching, such terms may be added to synonyms and/or as asides in the \u201cgloss\u201d part of definitions. That or which? These are so interchangeable that there isn\u2019t really a rule anymore. But as a guideline, use \u201cwhich\u201d after a comma (e.g., \u201cthis study, which cost $10,000, was a success\u201d), and \u201cthat\u201d when no comma is used (e.g., \u201cthe study that cost $10,000 was a success\u201d). Use of hyphens. Yes to those that help clarity (e.g., \u201cposterior-most\u201d) and those that are regularly used/accepted in the literature. Generally, no hyphens after prefixes such as \u201csub\u201d, \u201cmid\u201d, \u201csemi\u201d, \u201chemi\u201d, etc. (e.g., \u201chemidesmosome\u201d instead of \u201chemi-desmosome\u201d), unless it helps with clarity (e.g., \u201cmulti-innervated\u201d). No hyphens for composed location adjectives (e.g., \u201cposteroanterior\u201d), unless there are more than two compounds (e.g., \u201cventro-posterolateral\u201d). Abbreviations. Avoid abbreviations, contractions, and symbols born out of laziness, such as & , + , or vs for \u201cversus\u201d. Avoid abbreviations unless they are self-explanatory, commonly understood, or they really do help to reduce the amount of typing enough to enhance readability. Use full chemical element names, not symbols (e.g., \u201chydrogen\u201d instead of \u201cH+\u201d, \u201ccopper\u201d instead of \u201cCu\u201d, etc.). For biomolecules, spell out the term wherever practical (e.g., \u201cfibroblast growth factor\u201d instead of \u201cFGF\u201d). Abbreviations are acceptable in synonyms, in cases where the abbreviation is the synonym.","title":"Considerations on style"},{"location":"editing_guidelines/#cross-references-to-the-literature","text":"Assertions in textual definitions, evidence provided in comments, and synonyms should be backed up by citing the appropriate literature. Citations are made by cross-references, that is by adding http://www.geneontology.org/formats/oboInOwl#hasDbXref annotations to the definition, comment, and synonym annotations. Add one such annotation per reference, using the CURIE syntax with well-known prefixes: PMID:1234567 for a PubMed identifier; doi:xx.yyyy/... for a DOI; ISBN:... for a ISBN. If the main source for an assertion is a term in another ontology, the short identifier for that term may be used as a cross-reference. For example, WBbt:0006799 to cross-reference a term in the C. elegans Gross Anatomy Ontology. If using a MeSH (Medical Subject Heading) term as a cross-reference, add the database_cross_reference annotation using the MeSH Unique ID, NOT MeSH Tree Number. For example, a database_cross_reference can be MESH:D004759, NOT MESH:A03.492.766.440.250. ORCID identifiers may also be used when the only available source for an assertion is an individual researcher. However, this should be AVOIDED. Technical details of adding a cross-reference using Prot\u00e9g\u00e9 : For CURIEs, ORCIDs: In the \"Create Annotation\" window, select the annotation property database_cross_reference . For adding URLs to text definitions or synonyms: In the \"Create Annotation\" window, select the annotation property database_cross_reference . For adding URLs to axioms that are NOT text definitions or synonyms: In the \"Create Annotation\" window, select the annotation property source . For CURIEs: Enter the CURIE, using the bioregistry OBO context prefix ( link to prefixmap ), as a Value on the \"Literal\" tab. Leave Datatype empty. In cases where more than one CURIE is available for a resource, either is acceptable, but using the more semantically specific identifier is recommended. For example, when both a PMID and a doi are available for a resource, using the PMID is recommended since it indicates the cross-reference points to a paper, as opposed to a doi which could point to any digital object. For ORCIDs: Enter the ORCID as an IRI in the IRI field on the \"IRI Editor\" tab, for example https://orcid.org/0000-0002-7356-1779 . For URLs: Enter the URL as a literal string with Datatype xsd:anyURI selected. To restate, in all cases above except ORCIDs, the values are entered as literal strings. An ORCID MUST BE entered as an IRI.","title":"Cross-references to the literature"},{"location":"editing_guidelines/#term-contributors","text":"When adding an ORCID to identify a term contributor, in the \"Create Annotation\" window, select the annotation property dcterms:contributor . The ORCID is still entered as an IRI on the \u201cIRI Editor\u201d tab.","title":"Term contributors"},{"location":"editing_guidelines/#formal-definitions","text":"The formal definition of a class is made up of all the logical axioms about the class (as opposed to the annotation assertion axioms). This includes classification assertions, relationship assertions, equivalence assertions, and disjointness assertions. Note: In OWL formalism, both classification and relationship assertions are represented using SubClassOf axioms. However, in this document, we make a strict distinction between a classification (where a class is a subclass of a named class ), and a relationship (where a class is a subclass of an anonymous class expression ). For example, in the formal definition of CL:0000392 (\u201ccrystal cell\u201d): Class: 'crystal cell' SubClassOf: 'hemocyte' SubClassOf: 'develops from' some 'procrystal cell' The first SubClassOf axiom denotes an actual classification, whereas the second denotes a relationship.","title":"Formal definitions"},{"location":"editing_guidelines/#asserting-classification","text":"In order to keep the ontology maintainable, asserted classifications should be limited where possible. Ideally, all terms would have only a single asserted parent (also known as \u201csuperclass\u201d). Given the presence of suitable logically defined classes (see below) and sufficient relationships for the term you are making, additional classification can be inferred automatically by reasoning. However, as we are limited in what types of classification we are able to infer, you may need to assert multiple parents. Two asserted classifications are plainly acceptable. If you must assert three or more classifications, then you should make a note with a suggestion for which of the asserted classifications are good candidates for formalisation and inferred classification.","title":"Asserting classification"},{"location":"editing_guidelines/#logically-defined-classes","text":"Logically defined classes are terms that have formal definitions that specify complete necessary and sufficient conditions for membership of the class. They can be used by a reasoner to auto-classify the ontology by searching for terms that fulfill these conditions. Logically defined classes are variously referred to as \u201ccross-products\u201d (XPs), \u201cgenus and differentia definitions\u201d, \u201cequivalent classes\u201d, or \u201cintersections\u201d. In OWL formalism, they are represented using EquivalentClasses axioms. Generally, logical definitions follow the structure: \u201cAny X that REL some Y [and REL some Z ...]\u201d, where X is the genus and each following clause (\u201cthat REL some Y \u201d) is a differentium. Strictly speaking, logical definitions can be arbitrarily complex. It is recommended, however, to stick as much as possible to \u201csimple\u201d logical definitions following the structure above. More complex definitions are harder to understand, and may involve OWL constructs that are legal but not fully supported by the available reasoners. Good candidates for logically defined classes include classes whose only differentium is: what the cell is part of; what it innervates (or, if more precisely known, what its axon(s) or dendrite(s) innervate); its function. Care must be taken not to use logically defined classes too liberally. You should be satisfied that all automatic classifications that result would make sense (or at least be justifiable) to a biologist and would cover most cases of usages with as few edge cases as possible. If you are unsure whether a characteristic of a cell should be expressed as a relationship or as a differentium in a logically defined class: use a relationship. The textual definition of a logically defined class should be a plain English equivalent of the logical definition. However, in some cases it can be useful to add more details in the \u201cgloss\u201d part when relevant.","title":"Logically defined classes"},{"location":"editing_guidelines/#asserting-relationships","text":"Please refer to the relations guide for detailled guidelines about which relations to use for most cases.","title":"Asserting relationships"},{"location":"editing_guidelines/#design-pattern-usage-with-dosdp","text":"The cell ontology contains a large number of terms, classifications, and relationships that are constantly expanding. Manually maintaining all these elements would be a daunting task, so a substantial portion of the maintenance is automated. This automation heavily relies on the systematic use of design patterns. CL uses Dead simple OWL design patterns (DOSDP, Osumi-Sutherland et al. , 2017 ) to document simple patterns, as they require minimal programming expertise, and once implemented, it is easy to edit. All patterns are stored in /src/patterns/dosdp-patterns , while the editable tables are located in /src/patterns/data/default .","title":"Design Pattern Usage with DOSDP"},{"location":"editing_guidelines/#cycling-cell-states","text":"Pattern name: cyclingCellStates.yaml Cell cycling is a fundamental biological mechanism that brings a cell to divide and duplicate into two daughter cells. This process is carried out by a large number of cells, and cells undergoing cell cycling have a distinct transcriptional profile compared to non cycling cells. Cycling cells need to be annotated and described by CL terms as these cells have been identified in a multitude of single-cell transcriptional datasets. The terms created with this pattern are labeled as 'cycling X' , being X the parent term, and have an exact synonym 'proliferating X' . These cell terms can be logically defined as a 'cell' and 'participates in' some 'cell cycle process' and 'has quality' some 'active' . Ex: 'cycling B cell' SubClassOf 'B cell and 'participates in' some 'cell cycle process' and 'has quality' some 'active'","title":"Cycling cell states"},{"location":"history/","text":"A brief history of CL \u00b6 The Cell Ontology (CL) represents canonical, natural biological cell types in a variety of animal species, with a focus on vertebrates. It works in concert with the Uberon anatomy ontology, and integrates seamlessly with the Gene Ontology (GO). It is part of the Open Biological and Biomedical Ontology (OBO) Foundry. As of April 2022, CL consists of over 2400 classes, and is used by key projects that involve single-cell transcriptomics, such as HuBMAP (HuBMAP Consortium 2019), the Human Cell Atlas (Regev et al. 2017), the EBI Single Cell Expression Atlas (Papatheodorou et al. 2020), and the Brain Data Standards Ontology (Tan et al. 2021).","title":"History"},{"location":"history/#a-brief-history-of-cl","text":"The Cell Ontology (CL) represents canonical, natural biological cell types in a variety of animal species, with a focus on vertebrates. It works in concert with the Uberon anatomy ontology, and integrates seamlessly with the Gene Ontology (GO). It is part of the Open Biological and Biomedical Ontology (OBO) Foundry. As of April 2022, CL consists of over 2400 classes, and is used by key projects that involve single-cell transcriptomics, such as HuBMAP (HuBMAP Consortium 2019), the Human Cell Atlas (Regev et al. 2017), the EBI Single Cell Expression Atlas (Papatheodorou et al. 2020), and the Brain Data Standards Ontology (Tan et al. 2021).","title":"A brief history of CL"},{"location":"id-management/","text":"ID management in CL \u00b6 Temporary IDs \u00b6 \u201cTemporary IDs\u201d are an experimental mechanism to allow editors to mint new term IDs without worrying about potential conflicting IDs. This is primarily intended for AI agents, which are likely to open many PRs in parallel but have to share a single ID range (contrary to human editors, who all have their own range) and have no way of keeping track of which IDs are being used in concurrent PRs (again contrary to human editors, who can rely on Prot\u00e9g\u00e9 for that). However temporary IDs are in no way restricted to AI agents, and any editor could use them if they so want. For example, they could be useful for an external , occasional editor \u2013 someone who is not a known contributor to CL and for whom we may not necessarily want to allocate a dedicated ID range. Editing the ontology with temporary IDs \u00b6 From an editor\u2019s point of view, all that is needed to use temporary IDs is to use the Temporary IDs range defined in the cl-idranges.owl file. For editors using Prot\u00e9g\u00e9, this means selecting said Temporary IDs range when Prot\u00e9g\u00e9 asks you to select an ID range policy, just after having opened the Uberon edit file. For other editors (including AI agents), this means making sure that whenever a new ID is needed, it is generated within the range allocated to Temporary IDs (it should normally be CL:99NNNNN , but please check the contents of the cl-idranges.owl file, just in case the range is changed in the future). Replacing temporary IDs with definitive IDs \u00b6 Replacing temporary IDs with definitive IDs is done by invoking the allocate-definitive-ids target: sh run.sh make allocate-definitive-ids This will find all temporary IDs within the ontology and replace them with newly allocated definitive IDs picked from within the Automation range defined in the cl-idranges.owl file. All axioms that were referring to temporary IDs will be automatically re-written so that they refer to the corresponding newly allocated definitive IDs. This replacement must be performed at the latest possible stage, just before a PR is merged. If temporary IDs in a PR are replaced by definitive IDs, and the PR is then left unmerged for a while, then ID conflicts may occur when the PR is finally merged. For convenience, a GitHub Actions workflow is available to perform the ID replacement step on a PR without requiring a CL maintainer to check out the PR and invoke the allocate-definitive-ids manually. When a PR containing temporary IDs has been deemed OK for merging, a maintainer should trigger the allocate-definitive-ids GitHub Actions workflow on the PR\u2019s branch, wait for that workflow to terminate (it should take a couple of minutes at most), and then immediately merge the PR. Of note, the allocate-definitive-ids GitHub Actions workflow requires that a ID_ALLOCATION_TOKEN secret exist in the repository, associated to an account that is allowed to push to the repository. Automatic replacement of temporary IDs upon pushing to master \u00b6 Alternatively, a PR containing temporary IDs can be merged \u201cas is\u201d to the master branch. This will then trigger an automatic ID replacement operation (made by the same allocate-definitive-ids GitHub Actions workflow), directly on the master branch. Compared to the approach above, where the ID replacement is done on the PR prior to merging , this approach has the following advantages: it is entirely automated, and does not require any manual intervention from a maintainer; it eliminates the risk of an ID conflict still occurring between the moment IDs are replaced on a PR and the moment the PR is merged. It has the inconvenient that it lets temporary IDs becoming part of the history of the master branch, which may make perusing the history more cumbersome as the history will be \u201cpolluted\u201d by commits that do nothing more than rewriting IDs. With the \u201creplace-before-merging\u201d approach, such commits can be made invisible if the PR is small enough to allow for a \u201csquash merge\u201d instead of a normal merge \u2013 then only the definitive IDs will only ever make it to the master branch. This approach additionally requires that the account associated to the ID_ALLOCATION_TOKEN secret be allowed to push to the repository\u2019s master branch (bypassing the branch protection normally in place in CL).","title":"Managing terms IDs"},{"location":"id-management/#id-management-in-cl","text":"","title":"ID management in CL"},{"location":"id-management/#temporary-ids","text":"\u201cTemporary IDs\u201d are an experimental mechanism to allow editors to mint new term IDs without worrying about potential conflicting IDs. This is primarily intended for AI agents, which are likely to open many PRs in parallel but have to share a single ID range (contrary to human editors, who all have their own range) and have no way of keeping track of which IDs are being used in concurrent PRs (again contrary to human editors, who can rely on Prot\u00e9g\u00e9 for that). However temporary IDs are in no way restricted to AI agents, and any editor could use them if they so want. For example, they could be useful for an external , occasional editor \u2013 someone who is not a known contributor to CL and for whom we may not necessarily want to allocate a dedicated ID range.","title":"Temporary IDs"},{"location":"id-management/#editing-the-ontology-with-temporary-ids","text":"From an editor\u2019s point of view, all that is needed to use temporary IDs is to use the Temporary IDs range defined in the cl-idranges.owl file. For editors using Prot\u00e9g\u00e9, this means selecting said Temporary IDs range when Prot\u00e9g\u00e9 asks you to select an ID range policy, just after having opened the Uberon edit file. For other editors (including AI agents), this means making sure that whenever a new ID is needed, it is generated within the range allocated to Temporary IDs (it should normally be CL:99NNNNN , but please check the contents of the cl-idranges.owl file, just in case the range is changed in the future).","title":"Editing the ontology with temporary IDs"},{"location":"id-management/#replacing-temporary-ids-with-definitive-ids","text":"Replacing temporary IDs with definitive IDs is done by invoking the allocate-definitive-ids target: sh run.sh make allocate-definitive-ids This will find all temporary IDs within the ontology and replace them with newly allocated definitive IDs picked from within the Automation range defined in the cl-idranges.owl file. All axioms that were referring to temporary IDs will be automatically re-written so that they refer to the corresponding newly allocated definitive IDs. This replacement must be performed at the latest possible stage, just before a PR is merged. If temporary IDs in a PR are replaced by definitive IDs, and the PR is then left unmerged for a while, then ID conflicts may occur when the PR is finally merged. For convenience, a GitHub Actions workflow is available to perform the ID replacement step on a PR without requiring a CL maintainer to check out the PR and invoke the allocate-definitive-ids manually. When a PR containing temporary IDs has been deemed OK for merging, a maintainer should trigger the allocate-definitive-ids GitHub Actions workflow on the PR\u2019s branch, wait for that workflow to terminate (it should take a couple of minutes at most), and then immediately merge the PR. Of note, the allocate-definitive-ids GitHub Actions workflow requires that a ID_ALLOCATION_TOKEN secret exist in the repository, associated to an account that is allowed to push to the repository.","title":"Replacing temporary IDs with definitive IDs"},{"location":"id-management/#automatic-replacement-of-temporary-ids-upon-pushing-to-master","text":"Alternatively, a PR containing temporary IDs can be merged \u201cas is\u201d to the master branch. This will then trigger an automatic ID replacement operation (made by the same allocate-definitive-ids GitHub Actions workflow), directly on the master branch. Compared to the approach above, where the ID replacement is done on the PR prior to merging , this approach has the following advantages: it is entirely automated, and does not require any manual intervention from a maintainer; it eliminates the risk of an ID conflict still occurring between the moment IDs are replaced on a PR and the moment the PR is merged. It has the inconvenient that it lets temporary IDs becoming part of the history of the master branch, which may make perusing the history more cumbersome as the history will be \u201cpolluted\u201d by commits that do nothing more than rewriting IDs. With the \u201creplace-before-merging\u201d approach, such commits can be made invisible if the PR is small enough to allow for a \u201csquash merge\u201d instead of a normal merge \u2013 then only the definitive IDs will only ever make it to the master branch. This approach additionally requires that the account associated to the ID_ALLOCATION_TOKEN secret be allowed to push to the repository\u2019s master branch (bypassing the branch protection normally in place in CL).","title":"Automatic replacement of temporary IDs upon pushing to master"},{"location":"merging-terms/","text":"Merging Terms in CL \u00b6 How to merge terms \u00b6 For general instructions on how to merge terms, please see this How-to Guide In addition to the above, please add the annotation has_alternative_id on the winning term with the ID of the losing term. Considerations on which should be the winning term \u00b6 Check Usage by GO - This can be done by using AmiGO 2 Check Usage by other ontologies - This can be done by using Ontobee Check Usage within CL (you can do this in Protege with the usage tab) - this should be lower priority as you can easily change this while obsoleting the \"losing\" term","title":"Merging Terms in CL"},{"location":"merging-terms/#merging-terms-in-cl","text":"","title":"Merging Terms in CL"},{"location":"merging-terms/#how-to-merge-terms","text":"For general instructions on how to merge terms, please see this How-to Guide In addition to the above, please add the annotation has_alternative_id on the winning term with the ID of the losing term.","title":"How to merge terms"},{"location":"merging-terms/#considerations-on-which-should-be-the-winning-term","text":"Check Usage by GO - This can be done by using AmiGO 2 Check Usage by other ontologies - This can be done by using Ontobee Check Usage within CL (you can do this in Protege with the usage tab) - this should be lower priority as you can easily change this while obsoleting the \"losing\" term","title":"Considerations on which should be the winning term"},{"location":"presentations/","text":"Presentations \u00b6 Cell Ontology (Genentech presentation) by Nicole Vasilevsky. Presented on 2021-02-09.","title":"CL presentations"},{"location":"presentations/#presentations","text":"Cell Ontology (Genentech presentation) by Nicole Vasilevsky. Presented on 2021-02-09.","title":"Presentations"},{"location":"relations_guide/","text":"Cell Ontology (CL) relations guide. \u00b6 Intro \u00b6 The aim of this document is to provide an accessible guide to how to use relations to record the properties that define cell types including location, lineage, function, morphology and marker genes. The term 'relations' here refers principally to OWL object properties, but also includes annoation properties used as shortcuts for more expressive logical axioms that can be programatically generated from them. Relations in this guide are grouped by general use case (e.g. recording location) and each is illustrated by an example e.g.- melanocyte subClassOf \u2018has part\u2019 some melanosome. This should be read as \u2018 all melanocytes have some type of melanosome as a part\u2019 as should all axioms of this form. The examples should all be correct, but may not reflect the full complexity of axioms in the ontology. Where no example is currently present in CL, examples are taken from the Drosophila Anatomy Ontology, which follows the same schema. Recording location \u00b6 Location of cell types is recorded by relating a cell type to a term in an anatomical ontology. For the Cell Ontology this means a term from Uberon. 'part of' \u00b6 Use part_of for cases where the location is a material anatomical structure (rather than a space, such as a sinus) and all of the cell is within the anatomical structure. \u2018 epithelial cell' subClassOf 'part of' some epithelium \u2018part of\u2019 is transitive, which means that it applies across chains of relationships. For example, \u2018ileal goblet cell\u2019 part_of some ileum ilium \u2018part of\u2019 some \u2018small intestine\u2019 \u2018small intestine\u2019 \u2018part of\u2019 some intestine => \u2019ileal goblet cell\u2019 \u2018part of\u2019 some \u2018small intestine\u2019 & \u2018ileal goblet cell\u2019 \u2018part of\u2019 some intestine located_in \u00b6 To record the location of a cell in an anatomical space (e.g., a sinus), 'located in' is used. For example: \u2018 lymph node marginal reticular cell \u2019 subClassOf 'located in' some 'subcapsular sinus of lymph node' overlaps \u00b6 'part of' applies in cases where an entire cell is within an anatomical structure, but some cells have parts in multiple anatomical structures. For example, many neurons span multiple regions of the central nervous system. The general relation for this is overlaps (has some part in). overlaps is not currently used directly in the cell ontology (time of writing 05/2023), but more specific relationships exist for recording the location of neurons and their parts. These are described in the next section. Recording the location of neurons \u00b6 has soma location \u00b6 When neurobiologists talk about the location of vertebrate neurons, they are typically referring to soma location. The importance of soma location to identify is underscored by how commonly cell types are named, in part, by soma location. We therefore have a dedicated relation for recording this: 'has soma location' . For example, anterior horn motor neuron has the following subclass axiom: 'has soma location' some 'ventral horn of spinal cord' axiomatization of \u2018has soma location\u2019 subPropertyOf : overlaps # if X has_soma_location some Y, then X overlaps some Y) domain : neuron # X has_soma_location some Y => X is inferred to be a subClassOf neuron property chain : has_soma_location o part_of --> has_soma_location # If x has soma location y and y is part_of z, then x has_soma_location_z Example of reasoning with the property chain: 'cortical interneuron' equivalentTo 'interneuron' that has_soma_location some 'cerebral cortex' 'rosehip neuron' subClassOf interneuron and has_soma_location some 'cortical layer 1' 'cortical layer 1' subClassOf part_of some 'cerebral cortex => 'rosehip neuron' subClassOf 'cortical interneuron' sends synaptic output to region \u00b6 A relationship between a neuron and a region, where the neuron has a functionally relevant number of output synapses in that region. ' adult basket subesophageal neuron ' SubClassOf sends synaptic output to region some inferior posterior slope receives synaptic input in region \u00b6 A relationship between a neuron and a region, where the neuron has a functionally relevant number of input synapses: e.g. ' adult basket subesophageal neuron ' SubClassOf \u2018 receives synaptic input in region \u2019 some \u2018 superior posterior slope \u2019 fasciculates_with \u00b6 Use this to record the tracts or nerves that a neuron\u2019s projections fasciculate with. e.g. \u2018Betz cell\u2019 subClasssOf \u2018fasciculates with\u2019 some \u2018corticospinal tract\u2019. subPropertyOf: overlaps domain: neuron range: neuron projection bundle Recording synaptic connectivity (neurons) \u00b6 To record neuron-to-neuron or motor neuron-to-target muscle connectivity, consider the following object properties. These properties should be used when connectivity is key to the definition, for example, in cases where a motor neuron type is defined by the type of muscle fiber on which it synapses. synapsed to \u00b6 For example, 'alpha motor neuron' SubClassOf synapsed to some 'extrafusal muscle fiber' synapsed by \u00b6 This is the the inverse of synapsed to For example, 'extrafusal muscle fiber' SubClassOf synapsed by some 'alpha motor neuron' Recording function \u00b6 Cellular function is recorded by linking GO biological process terms with the object properties 'capable of' and \u2018capable of part of\u2019 'capable of' \u00b6 Use this relation where the cell is capable of carrying out the entirety of the process For example, 'hilus cell of ovary' has the following subclass: 'capable of' some 'androgen secretion' Recording neurotransmitter for neurons \u00b6 To record which neurotransmitter a neuron releases, use a 'capable of' relation to link the neuron to a subclass of GO neurotransmitter secretion that references a neurotransmitter type. This should be sufficient for autoclassification. e.g. 'medium spiny neuron' 'capable of' some 'gamma-aminobutyric acid secretion, neurotransmission' \u2018capable of part of\u2019 \u00b6 Use this relationship where only part of the process occurs in the cell type. e.g. 'retinal bipolar neuron' 'capable of part of' some 'visual perception' Recording developmental lineage \u00b6 Developmental lineage is recorded between cell types with the object property develops from (a transitive property), or in the case where there are no intermediates between the cells, 'directly develops from' (a non-transitive subproperty of develops_from ) For example, 'leukocyte' subClassOf develops from some 'hematopoietic stem cell' Recording cell markers \u00b6 Only markers that are necessary to define a cell type should be recorded. cell surface (protein) markers \u00b6 The cell ontology has a set of terms for recording cell surface markers. The most commonly used relation for recording markers is 'has plasma membrane part' . This object property is used to record cell surface markers, especially in immune cells. There are also more specific properties, 'has low plasma membrane amount' and 'has high plasma membrane amount' , that can be used at an editor's discretion. In each case, a term from the PRotein Ontology (PRO) or a protein complex term from the Gene Ontology (GO) is used as the object of the relation. For example, 'alpha-beta T cell' has the following equivalence axiom: 'T cell' and 'has plasma membrane part' some 'alpha-beta T cell receptor complex' Absence of a marker can be recorded using lacks_plasma_membrane_part Warning - this is used in place of the more accurate OWL expression \"NOT has_part some X*** in order to keep within the EL profile of OWL. It's use with a general class as a target can potentially lead to reasoning errors. recording gene markers \u00b6 \u2018expresses\u2019 \u00b6 Use this to link a cell type to a gene or gene product that defines it: For example: 'lamp5 GABAergic cortical interneuron' EquivalentTo: interneuron and ('has soma location' some 'cerebral cortex') and ('capable of' some 'gamma-aminobutyric acid secretion, neurotransmission') and (expresses some 'lysosome-associated membrane glycoprotein 5') In FBbt, FlyBase Gene IDs are permitted here (using standard resolvable URL pattern). In CL currenly only PRO IDs are permitted. In PCL, a broader range of IDs have been used (depending on data sources used). Recording cell parts \u00b6 To record parts above the granularity of proteins and complexes, use a 'has part' relationship with an object from the Gene Ontology cellular_component branch. e.g. 'melanocyte' subClassOf 'has part' some 'melanosome' This GO term can be combined with a PATO quality term (e.g. for shape) where necessary, e.g. For example: 'mature basophil' subClassOf ('has part' some (nucleus and ('has characteristic' some lobed))) Recording general cellular characteristics \u00b6 The ontology PATO , has a rich set of terms that can be used to record the general characteristics of cells, such as their morphology. These are recorded using 'has characteristic' . In choosing PATO terms, avoid those referring to some change in characteristic (e.g,.\u2019 increased branchiness\u2019). The following list of examples is not exhaustive: Recording Morphology \u00b6 PATO has a set of general morphology terms which may be applicable to cells. For example, erythrocyte subClassOf 'has characteristic' some biconcave PATO also has a set of terms for specific cell morphologies (mostly neuronal), e.g. \u2018Betz cell\u2019 subClassOf \u2018has characteristic\u2019 some \u2018standard pyramidal morphology\u2019 Recording nuclear number \u00b6 To record the number of nuclei in a cell, use a PATO subclass under the term 'nucleate quality' with the 'has characteristic' relation. For example, platelet subClassOf ( 'has_characteristic' some anucleate ) Note - that PATO includes bridging axioms that infer part relationships based on these characteristics. e.g. cell and ('has characteristic' some multinucleate) SubClassOf 'has part' some nucleus Taxon constraints \u00b6 See https://oboacademy.github.io/obook/explanation/taxon-constraints-explainer/ .","title":"CL relations"},{"location":"relations_guide/#cell-ontology-cl-relations-guide","text":"","title":"Cell Ontology (CL) relations guide."},{"location":"relations_guide/#intro","text":"The aim of this document is to provide an accessible guide to how to use relations to record the properties that define cell types including location, lineage, function, morphology and marker genes. The term 'relations' here refers principally to OWL object properties, but also includes annoation properties used as shortcuts for more expressive logical axioms that can be programatically generated from them. Relations in this guide are grouped by general use case (e.g. recording location) and each is illustrated by an example e.g.- melanocyte subClassOf \u2018has part\u2019 some melanosome. This should be read as \u2018 all melanocytes have some type of melanosome as a part\u2019 as should all axioms of this form. The examples should all be correct, but may not reflect the full complexity of axioms in the ontology. Where no example is currently present in CL, examples are taken from the Drosophila Anatomy Ontology, which follows the same schema.","title":"Intro"},{"location":"relations_guide/#recording-location","text":"Location of cell types is recorded by relating a cell type to a term in an anatomical ontology. For the Cell Ontology this means a term from Uberon.","title":"Recording location"},{"location":"relations_guide/#part-of","text":"Use part_of for cases where the location is a material anatomical structure (rather than a space, such as a sinus) and all of the cell is within the anatomical structure. \u2018 epithelial cell' subClassOf 'part of' some epithelium \u2018part of\u2019 is transitive, which means that it applies across chains of relationships. For example, \u2018ileal goblet cell\u2019 part_of some ileum ilium \u2018part of\u2019 some \u2018small intestine\u2019 \u2018small intestine\u2019 \u2018part of\u2019 some intestine => \u2019ileal goblet cell\u2019 \u2018part of\u2019 some \u2018small intestine\u2019 & \u2018ileal goblet cell\u2019 \u2018part of\u2019 some intestine","title":"'part of'"},{"location":"relations_guide/#located_in","text":"To record the location of a cell in an anatomical space (e.g., a sinus), 'located in' is used. For example: \u2018 lymph node marginal reticular cell \u2019 subClassOf 'located in' some 'subcapsular sinus of lymph node'","title":"located_in"},{"location":"relations_guide/#overlaps","text":"'part of' applies in cases where an entire cell is within an anatomical structure, but some cells have parts in multiple anatomical structures. For example, many neurons span multiple regions of the central nervous system. The general relation for this is overlaps (has some part in). overlaps is not currently used directly in the cell ontology (time of writing 05/2023), but more specific relationships exist for recording the location of neurons and their parts. These are described in the next section.","title":"overlaps"},{"location":"relations_guide/#recording-the-location-of-neurons","text":"","title":"Recording the location of neurons"},{"location":"relations_guide/#has-soma-location","text":"When neurobiologists talk about the location of vertebrate neurons, they are typically referring to soma location. The importance of soma location to identify is underscored by how commonly cell types are named, in part, by soma location. We therefore have a dedicated relation for recording this: 'has soma location' . For example, anterior horn motor neuron has the following subclass axiom: 'has soma location' some 'ventral horn of spinal cord' axiomatization of \u2018has soma location\u2019 subPropertyOf : overlaps # if X has_soma_location some Y, then X overlaps some Y) domain : neuron # X has_soma_location some Y => X is inferred to be a subClassOf neuron property chain : has_soma_location o part_of --> has_soma_location # If x has soma location y and y is part_of z, then x has_soma_location_z Example of reasoning with the property chain: 'cortical interneuron' equivalentTo 'interneuron' that has_soma_location some 'cerebral cortex' 'rosehip neuron' subClassOf interneuron and has_soma_location some 'cortical layer 1' 'cortical layer 1' subClassOf part_of some 'cerebral cortex => 'rosehip neuron' subClassOf 'cortical interneuron'","title":"has soma location"},{"location":"relations_guide/#sends-synaptic-output-to-region","text":"A relationship between a neuron and a region, where the neuron has a functionally relevant number of output synapses in that region. ' adult basket subesophageal neuron ' SubClassOf sends synaptic output to region some inferior posterior slope","title":"sends synaptic output to region"},{"location":"relations_guide/#receives-synaptic-input-in-region","text":"A relationship between a neuron and a region, where the neuron has a functionally relevant number of input synapses: e.g. ' adult basket subesophageal neuron ' SubClassOf \u2018 receives synaptic input in region \u2019 some \u2018 superior posterior slope \u2019","title":"receives synaptic input in region"},{"location":"relations_guide/#fasciculates_with","text":"Use this to record the tracts or nerves that a neuron\u2019s projections fasciculate with. e.g. \u2018Betz cell\u2019 subClasssOf \u2018fasciculates with\u2019 some \u2018corticospinal tract\u2019. subPropertyOf: overlaps domain: neuron range: neuron projection bundle","title":"fasciculates_with"},{"location":"relations_guide/#recording-synaptic-connectivity-neurons","text":"To record neuron-to-neuron or motor neuron-to-target muscle connectivity, consider the following object properties. These properties should be used when connectivity is key to the definition, for example, in cases where a motor neuron type is defined by the type of muscle fiber on which it synapses.","title":"Recording synaptic connectivity (neurons)"},{"location":"relations_guide/#synapsed-to","text":"For example, 'alpha motor neuron' SubClassOf synapsed to some 'extrafusal muscle fiber'","title":"synapsed to"},{"location":"relations_guide/#synapsed-by","text":"This is the the inverse of synapsed to For example, 'extrafusal muscle fiber' SubClassOf synapsed by some 'alpha motor neuron'","title":"synapsed by"},{"location":"relations_guide/#recording-function","text":"Cellular function is recorded by linking GO biological process terms with the object properties 'capable of' and \u2018capable of part of\u2019","title":"Recording function"},{"location":"relations_guide/#capable-of","text":"Use this relation where the cell is capable of carrying out the entirety of the process For example, 'hilus cell of ovary' has the following subclass: 'capable of' some 'androgen secretion'","title":"'capable of'"},{"location":"relations_guide/#recording-neurotransmitter-for-neurons","text":"To record which neurotransmitter a neuron releases, use a 'capable of' relation to link the neuron to a subclass of GO neurotransmitter secretion that references a neurotransmitter type. This should be sufficient for autoclassification. e.g. 'medium spiny neuron' 'capable of' some 'gamma-aminobutyric acid secretion, neurotransmission'","title":"Recording neurotransmitter for neurons"},{"location":"relations_guide/#capable-of-part-of","text":"Use this relationship where only part of the process occurs in the cell type. e.g. 'retinal bipolar neuron' 'capable of part of' some 'visual perception'","title":"\u2018capable of part of\u2019"},{"location":"relations_guide/#recording-developmental-lineage","text":"Developmental lineage is recorded between cell types with the object property develops from (a transitive property), or in the case where there are no intermediates between the cells, 'directly develops from' (a non-transitive subproperty of develops_from ) For example, 'leukocyte' subClassOf develops from some 'hematopoietic stem cell'","title":"Recording developmental lineage"},{"location":"relations_guide/#recording-cell-markers","text":"Only markers that are necessary to define a cell type should be recorded.","title":"Recording cell markers"},{"location":"relations_guide/#cell-surface-protein-markers","text":"The cell ontology has a set of terms for recording cell surface markers. The most commonly used relation for recording markers is 'has plasma membrane part' . This object property is used to record cell surface markers, especially in immune cells. There are also more specific properties, 'has low plasma membrane amount' and 'has high plasma membrane amount' , that can be used at an editor's discretion. In each case, a term from the PRotein Ontology (PRO) or a protein complex term from the Gene Ontology (GO) is used as the object of the relation. For example, 'alpha-beta T cell' has the following equivalence axiom: 'T cell' and 'has plasma membrane part' some 'alpha-beta T cell receptor complex' Absence of a marker can be recorded using lacks_plasma_membrane_part Warning - this is used in place of the more accurate OWL expression \"NOT has_part some X*** in order to keep within the EL profile of OWL. It's use with a general class as a target can potentially lead to reasoning errors.","title":"cell surface (protein) markers"},{"location":"relations_guide/#recording-gene-markers","text":"","title":"recording gene markers"},{"location":"relations_guide/#expresses","text":"Use this to link a cell type to a gene or gene product that defines it: For example: 'lamp5 GABAergic cortical interneuron' EquivalentTo: interneuron and ('has soma location' some 'cerebral cortex') and ('capable of' some 'gamma-aminobutyric acid secretion, neurotransmission') and (expresses some 'lysosome-associated membrane glycoprotein 5') In FBbt, FlyBase Gene IDs are permitted here (using standard resolvable URL pattern). In CL currenly only PRO IDs are permitted. In PCL, a broader range of IDs have been used (depending on data sources used).","title":"\u2018expresses\u2019"},{"location":"relations_guide/#recording-cell-parts","text":"To record parts above the granularity of proteins and complexes, use a 'has part' relationship with an object from the Gene Ontology cellular_component branch. e.g. 'melanocyte' subClassOf 'has part' some 'melanosome' This GO term can be combined with a PATO quality term (e.g. for shape) where necessary, e.g. For example: 'mature basophil' subClassOf ('has part' some (nucleus and ('has characteristic' some lobed)))","title":"Recording cell parts"},{"location":"relations_guide/#recording-general-cellular-characteristics","text":"The ontology PATO , has a rich set of terms that can be used to record the general characteristics of cells, such as their morphology. These are recorded using 'has characteristic' . In choosing PATO terms, avoid those referring to some change in characteristic (e.g,.\u2019 increased branchiness\u2019). The following list of examples is not exhaustive:","title":"Recording general cellular characteristics"},{"location":"relations_guide/#recording-morphology","text":"PATO has a set of general morphology terms which may be applicable to cells. For example, erythrocyte subClassOf 'has characteristic' some biconcave PATO also has a set of terms for specific cell morphologies (mostly neuronal), e.g. \u2018Betz cell\u2019 subClassOf \u2018has characteristic\u2019 some \u2018standard pyramidal morphology\u2019","title":"Recording Morphology"},{"location":"relations_guide/#recording-nuclear-number","text":"To record the number of nuclei in a cell, use a PATO subclass under the term 'nucleate quality' with the 'has characteristic' relation. For example, platelet subClassOf ( 'has_characteristic' some anucleate ) Note - that PATO includes bridging axioms that infer part relationships based on these characteristics. e.g. cell and ('has characteristic' some multinucleate) SubClassOf 'has part' some nucleus","title":"Recording nuclear number"},{"location":"relations_guide/#taxon-constraints","text":"See https://oboacademy.github.io/obook/explanation/taxon-constraints-explainer/ .","title":"Taxon constraints"},{"location":"resolving_merge_conflicts/","text":"A guide to resolving merge conflicts \u00b6 When you come to merge your pull request, you may find that conflicts prevent automated merging back into the master. In some cases, GitHub supports resolution of these through its web interface. However, probably due to file size, this is not currently supported for cl-edit.owl. The majority of the time, the conflict is trivial - due to addition of new terms to the same point in the file. Because terms are ordered in the file by ID, this happens whenever two edits add terms without any intervening IDs. Trivial clashes are easy to spot - they involve whole term stanzas + declarations. Occassionally non-trivial clashes will happen when two pull requests include edits to the same term or even the same axiom. Ask an editor for help if you don't feel confident resolving these. SOP. \u00b6 Reserialise the Master file using the Ontology Development Kit (ODK). This requires setting up Docker and ODK. If not already set up, follow the instructions here . Open Docker. At the line command (PC) or Terminal (Mac), use the cd (change directory) command to navigate to the repository's src/ontology/ directory. For example, ''' cd PATH_TO_ONTOLOGY/src/ontology/ ''' Replace \"PATH_TO_ONTOLOGY\" with the actual file path to the ontology. If you need to orient yourself, use the '''pwd''' (present working directory) or '''ls''' (list) line commands. If you are resolving a conflict in an .owl file, run: ''' sh run.sh make normalize_src ''' If you are resolving a conflict in an .obo file, run: ''' sh run.sh make normalize_obo_src ''' In CL, edits sometimes result in creating a large amount of uninteded differences involving ^^xsd:string. If you see these differences after running the command above, they can be resolved by following the instructions here . Resolving conflicts in GitHub Desktop and VSCode: 1) Update Branches in GitHub Desktop: Checkout Master and pull to make sure your Master branch is up to date. Checkout the branch for the pull request and make sure it is up to date. Choose Branch > Update from Master to integrate the latest changes from the master branch. GitHub Desktop will detect the clash and suggest opening it in your text editor of choice (e.g., Atom, VSCode). 2) Resolve Conflicts in VSCode: Open the conflicting file in VSCode. VSCode will highlight the conflicting areas with markers: For trivial ordering problems, either manually delete the conflict markers ( <<<<<<< , ======= , >>>>>>> ) and ensure all necessary declarations are retained, or click on Accept Both Changes . This will automatically merge all term declarations from both the HEAD and incoming changes, removing the conflict markers. Important - Always check that the change does look trivial before making any changes. 3) Reserialise OWL Files: It is essential to reserialise after resolving conflicts to ensure consistency and proper formatting: sh run.sh make normalize_src 4) Complete the Resolution Process: In GitHub Desktop, review the changes, commit the resolved conflict, and push the updates back to GitHub. Check the resulting diffs on the Pull Request on GitHub. Once the checks have run and are successful, merge and delete the branch.","title":"Resolving merge conflicts"},{"location":"resolving_merge_conflicts/#a-guide-to-resolving-merge-conflicts","text":"When you come to merge your pull request, you may find that conflicts prevent automated merging back into the master. In some cases, GitHub supports resolution of these through its web interface. However, probably due to file size, this is not currently supported for cl-edit.owl. The majority of the time, the conflict is trivial - due to addition of new terms to the same point in the file. Because terms are ordered in the file by ID, this happens whenever two edits add terms without any intervening IDs. Trivial clashes are easy to spot - they involve whole term stanzas + declarations. Occassionally non-trivial clashes will happen when two pull requests include edits to the same term or even the same axiom. Ask an editor for help if you don't feel confident resolving these.","title":"A guide to resolving merge conflicts"},{"location":"resolving_merge_conflicts/#sop","text":"Reserialise the Master file using the Ontology Development Kit (ODK). This requires setting up Docker and ODK. If not already set up, follow the instructions here . Open Docker. At the line command (PC) or Terminal (Mac), use the cd (change directory) command to navigate to the repository's src/ontology/ directory. For example, ''' cd PATH_TO_ONTOLOGY/src/ontology/ ''' Replace \"PATH_TO_ONTOLOGY\" with the actual file path to the ontology. If you need to orient yourself, use the '''pwd''' (present working directory) or '''ls''' (list) line commands. If you are resolving a conflict in an .owl file, run: ''' sh run.sh make normalize_src ''' If you are resolving a conflict in an .obo file, run: ''' sh run.sh make normalize_obo_src ''' In CL, edits sometimes result in creating a large amount of uninteded differences involving ^^xsd:string. If you see these differences after running the command above, they can be resolved by following the instructions here . Resolving conflicts in GitHub Desktop and VSCode: 1) Update Branches in GitHub Desktop: Checkout Master and pull to make sure your Master branch is up to date. Checkout the branch for the pull request and make sure it is up to date. Choose Branch > Update from Master to integrate the latest changes from the master branch. GitHub Desktop will detect the clash and suggest opening it in your text editor of choice (e.g., Atom, VSCode). 2) Resolve Conflicts in VSCode: Open the conflicting file in VSCode. VSCode will highlight the conflicting areas with markers: For trivial ordering problems, either manually delete the conflict markers ( <<<<<<< , ======= , >>>>>>> ) and ensure all necessary declarations are retained, or click on Accept Both Changes . This will automatically merge all term declarations from both the HEAD and incoming changes, removing the conflict markers. Important - Always check that the change does look trivial before making any changes. 3) Reserialise OWL Files: It is essential to reserialise after resolving conflicts to ensure consistency and proper formatting: sh run.sh make normalize_src 4) Complete the Resolution Process: In GitHub Desktop, review the changes, commit the resolved conflict, and push the updates back to GitHub. Check the resulting diffs on the Pull Request on GitHub. Once the checks have run and are successful, merge and delete the branch.","title":"SOP."},{"location":"taxon-restrictions/","text":"The cell ontology (CL) follows certain conventions regarding taxon constraints. Please review the following pages before adding taxon constraints to CL terms. Explanation of taxon constraints can be found here: https://oboacademy.github.io/obook/explanation/taxon-constraints-explainer/ A how-to guide can be found here: https://oboacademy.github.io/obook/howto/add-taxon-restrictions/","title":"Taxon constraints"},{"location":"textual_definitions_SOP/","text":"Guide to writing textual definitions on CL \u00b6 Relevant background material \u00b6 Chris Mungall's blog post on ontology term definitions OBO foundry reference paper Background \u00b6 It is standard ontology engineering practise to aim for minimal, concise ontology term definitions. However many cell types can be reliably identified by more than one set of properties: functional, structural, gene expression. This makes it hard to choose which properties to include if we are aiming for a minimal definition. Users of the cell ontology also come from different disciplines/perspectives and have different types of information and levels of detail available when they annotate a term or browse a resource. We need to be able to support users from multiple disciplines with a definition that allows them to visualise and identify the cell type being defined. In some cases (e.g. transcriptomically defined types or 't-types') identification of the cell type requires links to reference data. Here are a couple of examples of minimal definitions that are correct but not useful to most users: We could minimally define a corneal endothelial cell as 'Any endothelial cell that is part of the cornea'. This may well be sufficient for an expert in the anatomy and biology of the cornea, but to most biologists, the term \"endothelial cell\" brings to mind the principal cell types of lymphatic or blood vessels. However, \"corneal endothelium\" refers to a monolayer of flat cells on the underside of the cornea. Similarly, a perfectly accurate minimal definition of a type II pneuomocyte is an epithelial cell that has an 'alveolar lamellar body' (a unique structure only found in these cell types). But this is useless information to a user who knows nothing about this structure (many biologists) or who is annotating data that does not resolve this structure. A second use of ontologies is to encode knowledge in the form of useful formal links between ontology terms. For example, in CL we record function and cell components via links to gene ontology terms, location via links to CL and lineage via links to other CL terms. Not all of this information is particularly useful for recognising a cell type, but it is of use to our users and so we often record it in CL using formal relationships. This is relevant to ontology definitions because it is good practise for formal and textual definitions to match, and textual definitions are the place we encode supporting references. We can't of course, include every known piece of information about a cell in a definition (e.g. all genes expressed). However extended information is useful to our users - especially where it includes potential marker sets and information relevant to human physiology and disease. To support this, we have an additioal extended description field which can contain information about additional marker sets, minor (secondary) functions and disease. It can also contain information about properties that may not apply to all subclasses - this is especially useful for t-types in the brain where there is typically sparse knowledge of the extent of variation in morphology and function under each t-type. In these cases, information should be included about where these proporites do apply. SOP \u00b6 Definition \u00b6 Text in the definition field should be no longer than one short paragraph and should follow a classic genus, differentia and gloss type structure: - genus : what type of cell is it (e.g. epithelial cell) - differentia : a list of properties that can be used to distinguish it from other similar cell types, especially those in the same tissue/organ context and those of the same genus. This SHOULD include location unless the term is so abstract that this is not possible. We should be liberal in listing properties here in order to support multiple communities who will have different types of data and understanding. Structural and functional properties are preferred over molecular markers unless cell types are named for these markers or they are generally accepted as definitional by the community. Care should be taken not to attach species-specific markers to species-general cell types. Please note that while CL supports recording multiple marker sets for cell types, ideally with provenance, evidence and confidence, this is supported is outside of the core definition text. - gloss : Additional information not required for identification, including but not limited to, all assertions recorded in formal local assertions not covered in the differentia. This can include information about developmental origins, processes the cell is capable of (for example these may be secondary processes like a tendon cell's role stimulating an immune response when damaged) or roles that the cell may have. Extended description text. \u00b6 This is optional descriptive information in the rdfs:comment value (although we may switch to a dedicated annotation property in future). The text should be referenced following standard academic practice (minirefs in text, e.g. Avola et al ., 2024). It can include: - Descriptions of marker genes and marker gene sets. These MUST include species and provenance, and ideally evidence (e.g. identified by use of the NS-Forest algorithm on dataset x; identified by in-situ hybridization) and confidence. - Information specific to only some species or subtypes (where the applicability is known this should be made clear). - Information about the role of the cell type more broadly in disease and physiology. The comment section may also be used to record evidence and and name/synonym disambiguation. Defining transcriptomic types (t-types): \u00b6 Some cell types are defined with reference to transcriptomic data. This is especially common in brain datasets. In these cases, naming is often based on semi-automated transfer of names that are based on some specific set of properties. We do not always know how widely those properties apply so need to be careful in choosing them for differentia. Extended multi-modal descriptions may be available, for example based on patch-seq data, but this is typically derived from very sparse data, so such information belongs in the extended definition, along with details of the brain regions where these properties have been assayed. Definitions for these follow a different pattern: - First sentence: \"A transcriptomically distinct { genus } with { description of primary differentia here }. Second sentence may include more differentia. - Gloss: see above - Last sentence: The standard transcriptomic reference data for this cell type can be found on the { site } under { human readable details of how to access dataset }, { human readable details of annotation key/value pair that marks the reference cell set. Example : label: A transcriptomically distinct intratelencephalic-projecting glutamatergic neuron with a soma found between cortical layer 2-4. The standard transcriptomic reference data for this cell type can be found on the CellxGene census under the collection: \"Transcriptomic cytoarchitecture reveals principles of human neocortex organization\", dataset: \"Supercluster: IT-projecting excitatory neurons\", Author Categories: \"CrossArea_subclass\", value: L2/3 IT. Comment: In the barrel cortex (of rodents), these neurons have thin-tufted apical dendrites, extend their axonal projections into L5 in the neocortex and have a hyperpolarised resting membrane potential (Harris & Shepherd 2016). Historically, these neurons were identified in cortical layer 2/3. MERFISH data shows that this intratelencephalic-projecting glutametergic neuron can have its soma in layer 2/3, 4B, 4C (Jorstad et al., 2023). The position of the soma in layer 4b and 4C is less frequent for this neuronal type in comparison to cortical layer 2/3. Note: the reference dataset should MUST also be referenced directly via an xref. _Axiomatisation of t-types: Axiomatisation of t-types is tricky for a number of reasons: 1. Transcriptomic hierarchy does not necessarily follow property based hierarchy, for example we might define SST cortical interneurons as any cortical interneuron expressing SST. However, in transcriptomic hierarchies, one SST expressing type (SST CHODL) is only distantly related to the other SST cells and so is treated as a disjoint type (e.g. see Jorstad et al., 2023). 2. We have limited knowledge about how widely particular properties of t-types apply. In the former case, it is sufficient to express the property with a subClassOf axiom (avoiding use of equivalent class axioms). In the latter, mention of the property should be confined to the extended description, or in some cases we may use annotation properties. For example, in linking a single transcriptomic cell type to multiple brain regions or layers, an annotation property must be used. Given the limited knowledge we have about how and whether they are unique to a particular cell type, care needs to be taken in adding formal axioms recording them. Where there is a possibility that it is important to limit clauses in EquivalentClass expressions. We have a standard pattern that can be used to convert transcriptomic heirarchies into SubClassOf hierarchies - using equivalence axioms with a 'has_examplar' clause with value cell set (see Tan et al., 2023 for details). However care should be taken in using this given the potential for inheritance of properties that don't apply to all subclusters in a transcriptomic hierarchy. A formal link to a defining cell set can be represented using subClassOf in order to avoid this. References \u00b6 Harris, Kenneth D., and Gordon M. G. Shepherd. 2015. \u201cThe Neocortical Circuit: Themes and Variations.\u201d Nature Neuroscience 18 (2): 170\u201381. https://doi.org/10.1038/nn.3917. Jorstad, Nikolas L., Jennie Close, Nelson Johansen, Anna Marie Yanny, Eliza R. Barkan, Kyle J. Travaglini, Darren Bertagnolli, et al. 2023. \u201cTranscriptomic Cytoarchitecture Reveals Principles of Human Neocortex Organization.\u201d Science 382 (6667): eadf6812. https://doi.org/10.1126/science.adf6812. Tan, Shawn Zheng Kai, Huseyin Kir, Brian D. Aevermann, Tom Gillespie, Nomi Harris, Michael J. Hawrylycz, Nikolas L. Jorstad, et al. 2023. \u201cBrain Data Standards - A Method for Building Data-Driven Cell-Type Ontologies.\u201d Scientific Data 10 (1): 50. https://doi.org/10.1038/s41597-022-01886-2.","title":"textual definitions SOP"},{"location":"textual_definitions_SOP/#guide-to-writing-textual-definitions-on-cl","text":"","title":"Guide to writing textual definitions on CL"},{"location":"textual_definitions_SOP/#relevant-background-material","text":"Chris Mungall's blog post on ontology term definitions OBO foundry reference paper","title":"Relevant background material"},{"location":"textual_definitions_SOP/#background","text":"It is standard ontology engineering practise to aim for minimal, concise ontology term definitions. However many cell types can be reliably identified by more than one set of properties: functional, structural, gene expression. This makes it hard to choose which properties to include if we are aiming for a minimal definition. Users of the cell ontology also come from different disciplines/perspectives and have different types of information and levels of detail available when they annotate a term or browse a resource. We need to be able to support users from multiple disciplines with a definition that allows them to visualise and identify the cell type being defined. In some cases (e.g. transcriptomically defined types or 't-types') identification of the cell type requires links to reference data. Here are a couple of examples of minimal definitions that are correct but not useful to most users: We could minimally define a corneal endothelial cell as 'Any endothelial cell that is part of the cornea'. This may well be sufficient for an expert in the anatomy and biology of the cornea, but to most biologists, the term \"endothelial cell\" brings to mind the principal cell types of lymphatic or blood vessels. However, \"corneal endothelium\" refers to a monolayer of flat cells on the underside of the cornea. Similarly, a perfectly accurate minimal definition of a type II pneuomocyte is an epithelial cell that has an 'alveolar lamellar body' (a unique structure only found in these cell types). But this is useless information to a user who knows nothing about this structure (many biologists) or who is annotating data that does not resolve this structure. A second use of ontologies is to encode knowledge in the form of useful formal links between ontology terms. For example, in CL we record function and cell components via links to gene ontology terms, location via links to CL and lineage via links to other CL terms. Not all of this information is particularly useful for recognising a cell type, but it is of use to our users and so we often record it in CL using formal relationships. This is relevant to ontology definitions because it is good practise for formal and textual definitions to match, and textual definitions are the place we encode supporting references. We can't of course, include every known piece of information about a cell in a definition (e.g. all genes expressed). However extended information is useful to our users - especially where it includes potential marker sets and information relevant to human physiology and disease. To support this, we have an additioal extended description field which can contain information about additional marker sets, minor (secondary) functions and disease. It can also contain information about properties that may not apply to all subclasses - this is especially useful for t-types in the brain where there is typically sparse knowledge of the extent of variation in morphology and function under each t-type. In these cases, information should be included about where these proporites do apply.","title":"Background"},{"location":"textual_definitions_SOP/#sop","text":"","title":"SOP"},{"location":"textual_definitions_SOP/#definition","text":"Text in the definition field should be no longer than one short paragraph and should follow a classic genus, differentia and gloss type structure: - genus : what type of cell is it (e.g. epithelial cell) - differentia : a list of properties that can be used to distinguish it from other similar cell types, especially those in the same tissue/organ context and those of the same genus. This SHOULD include location unless the term is so abstract that this is not possible. We should be liberal in listing properties here in order to support multiple communities who will have different types of data and understanding. Structural and functional properties are preferred over molecular markers unless cell types are named for these markers or they are generally accepted as definitional by the community. Care should be taken not to attach species-specific markers to species-general cell types. Please note that while CL supports recording multiple marker sets for cell types, ideally with provenance, evidence and confidence, this is supported is outside of the core definition text. - gloss : Additional information not required for identification, including but not limited to, all assertions recorded in formal local assertions not covered in the differentia. This can include information about developmental origins, processes the cell is capable of (for example these may be secondary processes like a tendon cell's role stimulating an immune response when damaged) or roles that the cell may have.","title":"Definition"},{"location":"textual_definitions_SOP/#extended-description-text","text":"This is optional descriptive information in the rdfs:comment value (although we may switch to a dedicated annotation property in future). The text should be referenced following standard academic practice (minirefs in text, e.g. Avola et al ., 2024). It can include: - Descriptions of marker genes and marker gene sets. These MUST include species and provenance, and ideally evidence (e.g. identified by use of the NS-Forest algorithm on dataset x; identified by in-situ hybridization) and confidence. - Information specific to only some species or subtypes (where the applicability is known this should be made clear). - Information about the role of the cell type more broadly in disease and physiology. The comment section may also be used to record evidence and and name/synonym disambiguation.","title":"Extended description text."},{"location":"textual_definitions_SOP/#defining-transcriptomic-types-t-types","text":"Some cell types are defined with reference to transcriptomic data. This is especially common in brain datasets. In these cases, naming is often based on semi-automated transfer of names that are based on some specific set of properties. We do not always know how widely those properties apply so need to be careful in choosing them for differentia. Extended multi-modal descriptions may be available, for example based on patch-seq data, but this is typically derived from very sparse data, so such information belongs in the extended definition, along with details of the brain regions where these properties have been assayed. Definitions for these follow a different pattern: - First sentence: \"A transcriptomically distinct { genus } with { description of primary differentia here }. Second sentence may include more differentia. - Gloss: see above - Last sentence: The standard transcriptomic reference data for this cell type can be found on the { site } under { human readable details of how to access dataset }, { human readable details of annotation key/value pair that marks the reference cell set. Example : label: A transcriptomically distinct intratelencephalic-projecting glutamatergic neuron with a soma found between cortical layer 2-4. The standard transcriptomic reference data for this cell type can be found on the CellxGene census under the collection: \"Transcriptomic cytoarchitecture reveals principles of human neocortex organization\", dataset: \"Supercluster: IT-projecting excitatory neurons\", Author Categories: \"CrossArea_subclass\", value: L2/3 IT. Comment: In the barrel cortex (of rodents), these neurons have thin-tufted apical dendrites, extend their axonal projections into L5 in the neocortex and have a hyperpolarised resting membrane potential (Harris & Shepherd 2016). Historically, these neurons were identified in cortical layer 2/3. MERFISH data shows that this intratelencephalic-projecting glutametergic neuron can have its soma in layer 2/3, 4B, 4C (Jorstad et al., 2023). The position of the soma in layer 4b and 4C is less frequent for this neuronal type in comparison to cortical layer 2/3. Note: the reference dataset should MUST also be referenced directly via an xref. _Axiomatisation of t-types: Axiomatisation of t-types is tricky for a number of reasons: 1. Transcriptomic hierarchy does not necessarily follow property based hierarchy, for example we might define SST cortical interneurons as any cortical interneuron expressing SST. However, in transcriptomic hierarchies, one SST expressing type (SST CHODL) is only distantly related to the other SST cells and so is treated as a disjoint type (e.g. see Jorstad et al., 2023). 2. We have limited knowledge about how widely particular properties of t-types apply. In the former case, it is sufficient to express the property with a subClassOf axiom (avoiding use of equivalent class axioms). In the latter, mention of the property should be confined to the extended description, or in some cases we may use annotation properties. For example, in linking a single transcriptomic cell type to multiple brain regions or layers, an annotation property must be used. Given the limited knowledge we have about how and whether they are unique to a particular cell type, care needs to be taken in adding formal axioms recording them. Where there is a possibility that it is important to limit clauses in EquivalentClass expressions. We have a standard pattern that can be used to convert transcriptomic heirarchies into SubClassOf hierarchies - using equivalence axioms with a 'has_examplar' clause with value cell set (see Tan et al., 2023 for details). However care should be taken in using this given the potential for inheritance of properties that don't apply to all subclusters in a transcriptomic hierarchy. A formal link to a defining cell set can be represented using subClassOf in order to avoid this.","title":"Defining transcriptomic types (t-types):"},{"location":"textual_definitions_SOP/#references","text":"Harris, Kenneth D., and Gordon M. G. Shepherd. 2015. \u201cThe Neocortical Circuit: Themes and Variations.\u201d Nature Neuroscience 18 (2): 170\u201381. https://doi.org/10.1038/nn.3917. Jorstad, Nikolas L., Jennie Close, Nelson Johansen, Anna Marie Yanny, Eliza R. Barkan, Kyle J. Travaglini, Darren Bertagnolli, et al. 2023. \u201cTranscriptomic Cytoarchitecture Reveals Principles of Human Neocortex Organization.\u201d Science 382 (6667): eadf6812. https://doi.org/10.1126/science.adf6812. Tan, Shawn Zheng Kai, Huseyin Kir, Brian D. Aevermann, Tom Gillespie, Nomi Harris, Michael J. Hawrylycz, Nikolas L. Jorstad, et al. 2023. \u201cBrain Data Standards - A Method for Building Data-Driven Cell-Type Ontologies.\u201d Scientific Data 10 (1): 50. https://doi.org/10.1038/s41597-022-01886-2.","title":"References"},{"location":"odk-workflows/","text":"Default ODK Workflows \u00b6 Daily Editors Workflow Release Workflow Manage your ODK Repository Setting up Docker for ODK Imports management Managing the documentation Managing your Automated Testing","title":"Overview"},{"location":"odk-workflows/#default-odk-workflows","text":"Daily Editors Workflow Release Workflow Manage your ODK Repository Setting up Docker for ODK Imports management Managing the documentation Managing your Automated Testing","title":"Default ODK Workflows"},{"location":"odk-workflows/ContinuousIntegration/","text":"Introduction to Continuous Integration Workflows with ODK \u00b6 Historically, most repos have been using Travis CI for continuous integration testing and building, but due to runtime restrictions, we recently switched a lot of our repos to GitHub actions. You can set up your repo with CI by adding this to your configuration file (src/ontology/cl-odk.yaml): ci: - github_actions When updateing your repo , you will notice a new file being added: .github/workflows/qc.yml . This file contains your CI logic, so if you need to change, or add anything, this is the place! Alternatively, if your repo is in GitLab instead of GitHub, you can set up your repo with GitLab CI by adding this to your configuration file (src/ontology/cl-odk.yaml): ci: - gitlab-ci This will add a file called .gitlab-ci.yml in the root of your repo.","title":"Continuous Integration"},{"location":"odk-workflows/ContinuousIntegration/#introduction-to-continuous-integration-workflows-with-odk","text":"Historically, most repos have been using Travis CI for continuous integration testing and building, but due to runtime restrictions, we recently switched a lot of our repos to GitHub actions. You can set up your repo with CI by adding this to your configuration file (src/ontology/cl-odk.yaml): ci: - github_actions When updateing your repo , you will notice a new file being added: .github/workflows/qc.yml . This file contains your CI logic, so if you need to change, or add anything, this is the place! Alternatively, if your repo is in GitLab instead of GitHub, you can set up your repo with GitLab CI by adding this to your configuration file (src/ontology/cl-odk.yaml): ci: - gitlab-ci This will add a file called .gitlab-ci.yml in the root of your repo.","title":"Introduction to Continuous Integration Workflows with ODK"},{"location":"odk-workflows/EditorsWorkflow/","text":"Editors Workflow \u00b6 The editors workflow is one of the formal workflows to ensure that the ontology is developed correctly according to ontology engineering principles. There are a few different editors workflows: Local editing workflow: Editing the ontology in your local environment by hand, using tools such as Prot\u00e9g\u00e9, ROBOT templates or DOSDP patterns. Completely automated data pipeline (GitHub Actions) DROID workflow This document only covers the first editing workflow, but more will be added in the future Local editing workflow \u00b6 Workflow requirements: git github docker editing tool of choice, e.g. Prot\u00e9g\u00e9, your favourite text editor, etc 1. Create issue \u00b6 Ensure that there is a ticket on your issue tracker that describes the change you are about to make. While this seems optional, this is a very important part of the social contract of building an ontology - no change to the ontology should be performed without a good ticket, describing the motivation and nature of the intended change. 2. Update main branch \u00b6 In your local environment (e.g. your laptop), make sure you are on the main (prev. master ) branch and ensure that you have all the upstream changes, for example: git checkout master git pull 3. Create feature branch \u00b6 Create a new branch. Per convention, we try to use meaningful branch names such as: - issue23removeprocess (where issue 23 is the related issue on GitHub) - issue26addcontributor - release20210101 (for releases) On your command line, this looks like this: git checkout -b issue23removeprocess 4. Perform edit \u00b6 Using your editor of choice, perform the intended edit. For example: Prot\u00e9g\u00e9 Open src/ontology/cl-edit.owl in Prot\u00e9g\u00e9 Make the change Save the file TextEdit Open src/ontology/cl-edit.owl in TextEdit (or Sublime, Atom, Vim, Nano) Make the change Save the file Consider the following when making the edit. According to our development philosophy, the only places that should be manually edited are: src/ontology/cl-edit.owl Any ROBOT templates you chose to use (the TSV files only) Any DOSDP data tables you chose to use (the TSV files, and potentially the associated patterns) components (anything in src/ontology/components ), see here . Imports should not be edited (any edits will be flushed out with the next update). However, refreshing imports is a potentially breaking change - and is discussed elsewhere . Changes should usually be small. Adding or changing 1 term is great. Adding or changing 10 related terms is ok. Adding or changing 100 or more terms at once should be considered very carefully. 4. Check the Git diff \u00b6 This step is very important. Rather than simply trusting your change had the intended effect, we should always use a git diff as a first pass for sanity checking. In our experience, having a visual git client like GitHub Desktop or sourcetree is really helpful for this part. In case you prefer the command line: git status git diff 5. Quality control \u00b6 Now it's time to run your quality control checks. This can either happen locally ( 5a ) or through your continuous integration system ( 7/5b ). 5a. Local testing \u00b6 If you chose to run your test locally: sh run.sh make IMP=false test This will run the whole set of configured ODK tests on including your change. If you have a complex DOSDP pattern pipeline you may want to add PAT=false to skip the potentially lengthy process of rebuilding the patterns. sh run.sh make IMP=false PAT=false test 6. Pull request \u00b6 When you are happy with the changes, you commit your changes to your feature branch, push them upstream (to GitHub) and create a pull request. For example: git add NAMEOFCHANGEDFILES git commit -m \"Added biological process term #12\" git push -u origin issue23removeprocess Then you go to your project on GitHub, and create a new pull request from the branch, for example: https://github.com/INCATools/ontology-development-kit/pulls There is a lot of great advise on how to write pull requests, but at the very least you should: - mention the tickets affected: see #23 to link to a related ticket, or fixes #23 if, by merging this pull request, the ticket is fixed. Tickets in the latter case will be closed automatically by GitHub when the pull request is merged. - summarise the changes in a few sentences. Consider the reviewer: what would they want to know right away. - If the diff is large, provide instructions on how to review the pull request best (sometimes, there are many changed files, but only one important change). 7/5b. Continuous Integration Testing \u00b6 If you didn't run and local quality control checks (see 5a ), you should have Continuous Integration (CI) set up, for example: - Travis - GitHub Actions More on how to set this up here . Once the pull request is created, the CI will automatically trigger. If all is fine, it will show up green, otherwise red. 8. Community review \u00b6 Once all the automatic tests have passed, it is important to put a second set of eyes on the pull request. Ontologies are inherently social - as in that they represent some kind of community consensus on how a domain is organised conceptually. This seems high brow talk, but it is very important that as an ontology editor, you have your work validated by the community you are trying to serve (e.g. your colleagues, other contributors etc.). In our experience, it is hard to get more than one review on a pull request - two is great. You can set up GitHub branch protection to actually require a review before a pull request can be merged! We recommend this. This step seems daunting to some hopefully under-resourced ontologies, but we recommend to put this high up on your list of priorities - train a colleague, reach out! 9. Merge and cleanup \u00b6 When the QC is green and the reviews are in (approvals), it is time to merge the pull request. After the pull request is merged, remember to delete the branch as well (this option will show up as a big button right after you have merged the pull request). If you have not done so, close all the associated tickets fixed by the pull request. 10. Changelog (Optional) \u00b6 It is sometimes difficult to keep track of changes made to an ontology. Some ontology teams opt to document changes in a changelog (simply a text file in your repository) so that when release day comes, you know everything you have changed. This is advisable at least for major changes (such as a new release system, a new pattern or template etc.).","title":"Editors Workflow"},{"location":"odk-workflows/EditorsWorkflow/#editors-workflow","text":"The editors workflow is one of the formal workflows to ensure that the ontology is developed correctly according to ontology engineering principles. There are a few different editors workflows: Local editing workflow: Editing the ontology in your local environment by hand, using tools such as Prot\u00e9g\u00e9, ROBOT templates or DOSDP patterns. Completely automated data pipeline (GitHub Actions) DROID workflow This document only covers the first editing workflow, but more will be added in the future","title":"Editors Workflow"},{"location":"odk-workflows/EditorsWorkflow/#local-editing-workflow","text":"Workflow requirements: git github docker editing tool of choice, e.g. Prot\u00e9g\u00e9, your favourite text editor, etc","title":"Local editing workflow"},{"location":"odk-workflows/EditorsWorkflow/#1-create-issue","text":"Ensure that there is a ticket on your issue tracker that describes the change you are about to make. While this seems optional, this is a very important part of the social contract of building an ontology - no change to the ontology should be performed without a good ticket, describing the motivation and nature of the intended change.","title":"1. Create issue"},{"location":"odk-workflows/EditorsWorkflow/#2-update-main-branch","text":"In your local environment (e.g. your laptop), make sure you are on the main (prev. master ) branch and ensure that you have all the upstream changes, for example: git checkout master git pull","title":"2. Update main branch"},{"location":"odk-workflows/EditorsWorkflow/#3-create-feature-branch","text":"Create a new branch. Per convention, we try to use meaningful branch names such as: - issue23removeprocess (where issue 23 is the related issue on GitHub) - issue26addcontributor - release20210101 (for releases) On your command line, this looks like this: git checkout -b issue23removeprocess","title":"3. Create feature branch"},{"location":"odk-workflows/EditorsWorkflow/#4-perform-edit","text":"Using your editor of choice, perform the intended edit. For example: Prot\u00e9g\u00e9 Open src/ontology/cl-edit.owl in Prot\u00e9g\u00e9 Make the change Save the file TextEdit Open src/ontology/cl-edit.owl in TextEdit (or Sublime, Atom, Vim, Nano) Make the change Save the file Consider the following when making the edit. According to our development philosophy, the only places that should be manually edited are: src/ontology/cl-edit.owl Any ROBOT templates you chose to use (the TSV files only) Any DOSDP data tables you chose to use (the TSV files, and potentially the associated patterns) components (anything in src/ontology/components ), see here . Imports should not be edited (any edits will be flushed out with the next update). However, refreshing imports is a potentially breaking change - and is discussed elsewhere . Changes should usually be small. Adding or changing 1 term is great. Adding or changing 10 related terms is ok. Adding or changing 100 or more terms at once should be considered very carefully.","title":"4. Perform edit"},{"location":"odk-workflows/EditorsWorkflow/#4-check-the-git-diff","text":"This step is very important. Rather than simply trusting your change had the intended effect, we should always use a git diff as a first pass for sanity checking. In our experience, having a visual git client like GitHub Desktop or sourcetree is really helpful for this part. In case you prefer the command line: git status git diff","title":"4. Check the Git diff"},{"location":"odk-workflows/EditorsWorkflow/#5-quality-control","text":"Now it's time to run your quality control checks. This can either happen locally ( 5a ) or through your continuous integration system ( 7/5b ).","title":"5. Quality control"},{"location":"odk-workflows/EditorsWorkflow/#5a-local-testing","text":"If you chose to run your test locally: sh run.sh make IMP=false test This will run the whole set of configured ODK tests on including your change. If you have a complex DOSDP pattern pipeline you may want to add PAT=false to skip the potentially lengthy process of rebuilding the patterns. sh run.sh make IMP=false PAT=false test","title":"5a. Local testing"},{"location":"odk-workflows/EditorsWorkflow/#6-pull-request","text":"When you are happy with the changes, you commit your changes to your feature branch, push them upstream (to GitHub) and create a pull request. For example: git add NAMEOFCHANGEDFILES git commit -m \"Added biological process term #12\" git push -u origin issue23removeprocess Then you go to your project on GitHub, and create a new pull request from the branch, for example: https://github.com/INCATools/ontology-development-kit/pulls There is a lot of great advise on how to write pull requests, but at the very least you should: - mention the tickets affected: see #23 to link to a related ticket, or fixes #23 if, by merging this pull request, the ticket is fixed. Tickets in the latter case will be closed automatically by GitHub when the pull request is merged. - summarise the changes in a few sentences. Consider the reviewer: what would they want to know right away. - If the diff is large, provide instructions on how to review the pull request best (sometimes, there are many changed files, but only one important change).","title":"6. Pull request"},{"location":"odk-workflows/EditorsWorkflow/#75b-continuous-integration-testing","text":"If you didn't run and local quality control checks (see 5a ), you should have Continuous Integration (CI) set up, for example: - Travis - GitHub Actions More on how to set this up here . Once the pull request is created, the CI will automatically trigger. If all is fine, it will show up green, otherwise red.","title":"7/5b. Continuous Integration Testing"},{"location":"odk-workflows/EditorsWorkflow/#8-community-review","text":"Once all the automatic tests have passed, it is important to put a second set of eyes on the pull request. Ontologies are inherently social - as in that they represent some kind of community consensus on how a domain is organised conceptually. This seems high brow talk, but it is very important that as an ontology editor, you have your work validated by the community you are trying to serve (e.g. your colleagues, other contributors etc.). In our experience, it is hard to get more than one review on a pull request - two is great. You can set up GitHub branch protection to actually require a review before a pull request can be merged! We recommend this. This step seems daunting to some hopefully under-resourced ontologies, but we recommend to put this high up on your list of priorities - train a colleague, reach out!","title":"8. Community review"},{"location":"odk-workflows/EditorsWorkflow/#9-merge-and-cleanup","text":"When the QC is green and the reviews are in (approvals), it is time to merge the pull request. After the pull request is merged, remember to delete the branch as well (this option will show up as a big button right after you have merged the pull request). If you have not done so, close all the associated tickets fixed by the pull request.","title":"9. Merge and cleanup"},{"location":"odk-workflows/EditorsWorkflow/#10-changelog-optional","text":"It is sometimes difficult to keep track of changes made to an ontology. Some ontology teams opt to document changes in a changelog (simply a text file in your repository) so that when release day comes, you know everything you have changed. This is advisable at least for major changes (such as a new release system, a new pattern or template etc.).","title":"10. Changelog (Optional)"},{"location":"odk-workflows/ManageAutomatedTest/","text":"Constraint violation checks \u00b6 We can define custom checks using SPARQL . SPARQL queries define bad modelling patterns (missing labels, misspelt URIs, and many more) in the ontology. If these queries return any results, then the build will fail. Custom checks are designed to be run as part of GitHub Actions Continuous Integration testing, but they can also run locally. Steps to add a constraint violation check: \u00b6 Add the SPARQL query in src/sparql . The name of the file should end with -violation.sparql . Please give a name that helps to understand which violation the query wants to check. Add the name of the new file to odk configuration file src/ontology/uberon-odk.yaml : Include the name of the file (without the -violation.sparql part) to the list inside the key custom_sparql_checks that is inside robot_report key. If the robot_report or custom_sparql_checks keys are not available, please add this code block to the end of the file. yaml robot_report: release_reports: False fail_on: ERROR use_labels: False custom_profile: True report_on: - edit custom_sparql_checks: - name-of-the-file-check 3. Update the repository so your new SPARQL check will be included in the QC. sh run.sh make update_repo","title":"ManageAutomatedTest"},{"location":"odk-workflows/ManageAutomatedTest/#constraint-violation-checks","text":"We can define custom checks using SPARQL . SPARQL queries define bad modelling patterns (missing labels, misspelt URIs, and many more) in the ontology. If these queries return any results, then the build will fail. Custom checks are designed to be run as part of GitHub Actions Continuous Integration testing, but they can also run locally.","title":"Constraint violation checks"},{"location":"odk-workflows/ManageAutomatedTest/#steps-to-add-a-constraint-violation-check","text":"Add the SPARQL query in src/sparql . The name of the file should end with -violation.sparql . Please give a name that helps to understand which violation the query wants to check. Add the name of the new file to odk configuration file src/ontology/uberon-odk.yaml : Include the name of the file (without the -violation.sparql part) to the list inside the key custom_sparql_checks that is inside robot_report key. If the robot_report or custom_sparql_checks keys are not available, please add this code block to the end of the file. yaml robot_report: release_reports: False fail_on: ERROR use_labels: False custom_profile: True report_on: - edit custom_sparql_checks: - name-of-the-file-check 3. Update the repository so your new SPARQL check will be included in the QC. sh run.sh make update_repo","title":"Steps to add a constraint violation check:"},{"location":"odk-workflows/ManageDocumentation/","text":"Updating the Documentation \u00b6 The documentation for CL is managed in two places (relative to the repository root): The docs directory contains all the files that pertain to the content of the documentation (more below) the mkdocs.yaml file contains the documentation config, in particular its navigation bar and theme. The documentation is hosted using GitHub pages, on a special branch of the repository (called gh-pages ). It is important that this branch is never deleted - it contains all the files GitHub pages needs to render and deploy the site. It is also important to note that the gh-pages branch should never be edited manually . All changes to the docs happen inside the docs directory on the main branch. Editing the docs \u00b6 Changing content \u00b6 All the documentation is contained in the docs directory, and is managed in Markdown . Markdown is a very simple and convenient way to produce text documents with formatting instructions, and is very easy to learn - it is also used, for example, in GitHub issues. This is a normal editing workflow: Open the .md file you want to change in an editor of choice (a simple text editor is often best). IMPORTANT : Do not edit any files in the docs/odk-workflows/ directory. These files are managed by the ODK system and will be overwritten when the repository is upgraded! If you wish to change these files, make an issue on the ODK issue tracker . Perform the edit and save the file Commit the file to a branch, and create a pull request as usual. If your development team likes your changes, merge the docs into master branch. Deploy the documentation (see below) Deploy the documentation \u00b6 The documentation is not automatically updated from the Markdown, and needs to be deployed deliberately. To do this, perform the following steps: In your terminal, navigate to the edit directory of your ontology, e.g.: cd cl/src/ontology Now you are ready to build the docs as follows: sh run.sh make update_docs Mkdocs now sets off to build the site from the markdown pages. You will be asked to Enter your username Enter your password (see here for using GitHub access tokens instead) IMPORTANT : Using password based authentication will be deprecated this year (2021). Make sure you read up on personal access tokens if that happens! If everything was successful, you will see a message similar to this one: INFO - Your documentation should shortly be available at: https://obophenotype.github.io/cell-ontology/ 3. Just to double check, you can now navigate to your documentation pages (usually https://obophenotype.github.io/cell-ontology/). Just make sure you give GitHub 2-5 minutes to build the pages!","title":"Managing the documentation"},{"location":"odk-workflows/ManageDocumentation/#updating-the-documentation","text":"The documentation for CL is managed in two places (relative to the repository root): The docs directory contains all the files that pertain to the content of the documentation (more below) the mkdocs.yaml file contains the documentation config, in particular its navigation bar and theme. The documentation is hosted using GitHub pages, on a special branch of the repository (called gh-pages ). It is important that this branch is never deleted - it contains all the files GitHub pages needs to render and deploy the site. It is also important to note that the gh-pages branch should never be edited manually . All changes to the docs happen inside the docs directory on the main branch.","title":"Updating the Documentation"},{"location":"odk-workflows/ManageDocumentation/#editing-the-docs","text":"","title":"Editing the docs"},{"location":"odk-workflows/ManageDocumentation/#changing-content","text":"All the documentation is contained in the docs directory, and is managed in Markdown . Markdown is a very simple and convenient way to produce text documents with formatting instructions, and is very easy to learn - it is also used, for example, in GitHub issues. This is a normal editing workflow: Open the .md file you want to change in an editor of choice (a simple text editor is often best). IMPORTANT : Do not edit any files in the docs/odk-workflows/ directory. These files are managed by the ODK system and will be overwritten when the repository is upgraded! If you wish to change these files, make an issue on the ODK issue tracker . Perform the edit and save the file Commit the file to a branch, and create a pull request as usual. If your development team likes your changes, merge the docs into master branch. Deploy the documentation (see below)","title":"Changing content"},{"location":"odk-workflows/ManageDocumentation/#deploy-the-documentation","text":"The documentation is not automatically updated from the Markdown, and needs to be deployed deliberately. To do this, perform the following steps: In your terminal, navigate to the edit directory of your ontology, e.g.: cd cl/src/ontology Now you are ready to build the docs as follows: sh run.sh make update_docs Mkdocs now sets off to build the site from the markdown pages. You will be asked to Enter your username Enter your password (see here for using GitHub access tokens instead) IMPORTANT : Using password based authentication will be deprecated this year (2021). Make sure you read up on personal access tokens if that happens! If everything was successful, you will see a message similar to this one: INFO - Your documentation should shortly be available at: https://obophenotype.github.io/cell-ontology/ 3. Just to double check, you can now navigate to your documentation pages (usually https://obophenotype.github.io/cell-ontology/). Just make sure you give GitHub 2-5 minutes to build the pages!","title":"Deploy the documentation"},{"location":"odk-workflows/ReleaseWorkflow/","text":"The release workflow \u00b6 The release workflow recommended by the ODK is based on GitHub releases and works as follows: Run a release with the ODK Review the release Merge to main branch Create a GitHub release These steps are outlined in detail in the following. Run a release with the ODK \u00b6 Preparation: Ensure that all your pull requests are merged into your main (master) branch Make sure that all changes to master are committed to GitHub ( git status should say that there are no modified files) Locally make sure you have the latest changes from master ( git pull ) Checkout a new branch (e.g. git checkout -b release-2021-01-01 ) You may or may not want to refresh your imports as part of your release strategy (see here ) Make sure you have the latest ODK installed by running docker pull obolibrary/odkfull To actually run the release, you: Open a command line terminal window and navigate to the src/ontology directory ( cd cl/src/ontology ) Run release pipeline: sh run.sh make prepare_release -B . Note that for some ontologies, this process can take up to 90 minutes - especially if there are large ontologies you depend on, like PRO or CHEBI. If everything went well, you should see the following output on your machine: Release files are now in ../.. - now you should commit, push and make a release on your git hosting site such as GitHub or GitLab . This will create all the specified release targets (OBO, OWL, JSON, and the variants, ont-full and ont-base) and copy them into your release directory (the top level of your repo). Review the release \u00b6 (Optional) Rough check. This step is frequently skipped, but for the more paranoid among us (like the author of this doc), this is a 3 minute additional effort for some peace of mind. Open the main release (cl.owl) in you favourite development environment (i.e. Prot\u00e9g\u00e9) and eyeball the hierarchy. We recommend two simple checks: Does the very top level of the hierarchy look ok? This means that all new terms have been imported/updated correctly. Does at least one change that you know should be in this release appear? For example, a new class. This means that the release was actually based on the recent edit file. Commit your changes to the branch and make a pull request In your GitHub pull request, review the following three files in detail (based on our experience): cl.obo - this reflects a useful subset of the whole ontology (everything that can be covered by OBO format). OBO format has that speaking for it: it is very easy to review! cl-base.owl - this reflects the asserted axioms in your ontology that you have actually edited. Ideally also take a look at cl-full.owl , which may reveal interesting new inferences you did not know about. Note that the diff of this file is sometimes quite large. Like with every pull request, we recommend to always employ a second set of eyes when reviewing a PR! Merge the main branch \u00b6 Once your CI checks have passed, and your reviews are completed, you can now merge the branch into your main branch (don't forget to delete the branch afterwards - a big button will appear after the merge is finished). Create a GitHub release \u00b6 Go to your releases page on GitHub by navigating to your repository, and then clicking on releases (usually on the right, for example: https://github.com/obophenotype/cell-ontology/releases). Then click \"Draft new release\" As the tag version you need to choose the date on which your ontologies were build. You can find this, for example, by looking at the cl.obo file and check the data-version: property. The date needs to be prefixed with a v , so, for example v2020-02-06 . You can write whatever you want in the release title, but we typically write the date again. The description underneath should contain a concise list of changes or term additions. Click \"Publish release\". Done. Debugging typical ontology release problems \u00b6 Problems with memory \u00b6 When you are dealing with large ontologies, you need a lot of memory. When you see error messages relating to large ontologies such as CHEBI, PRO, NCBITAXON, or Uberon, you should think of memory first, see here . Problems when using OBO format based tools \u00b6 Sometimes you will get cryptic error messages when using legacy tools using OBO format, such as the ontology release tool (OORT), which is also available as part of the ODK docker container. In these cases, you need to track down what axiom or annotation actually caused the breakdown. In our experience (in about 60% of the cases) the problem lies with duplicate annotations ( def , comment ) which are illegal in OBO. Here is an example recipe of how to deal with such a problem: If you get a message like make: *** [cl.Makefile:84: oort] Error 255 you might have a OORT error. To debug this, in your terminal enter sh run.sh make IMP=false PAT=false oort -B (assuming you are already in the ontology folder in your directory) This should show you where the error is in the log (eg multiple different definitions) WARNING: THE FIX BELOW IS NOT IDEAL, YOU SHOULD ALWAYS TRY TO FIX UPSTREAM IF POSSIBLE Open cl-edit.owl in Prot\u00e9g\u00e9 and find the offending term and delete all offending issue (e.g. delete ALL definition, if the problem was \"multiple def tags not allowed\") and save. *While this is not idea, as it will remove all definitions from that term, it will be added back again when the term is fixed in the ontology it was imported from and added back in. Rerun sh run.sh make IMP=false PAT=false oort -B and if it all passes, commit your changes to a branch and make a pull request as usual.","title":"Release Workflow"},{"location":"odk-workflows/ReleaseWorkflow/#the-release-workflow","text":"The release workflow recommended by the ODK is based on GitHub releases and works as follows: Run a release with the ODK Review the release Merge to main branch Create a GitHub release These steps are outlined in detail in the following.","title":"The release workflow"},{"location":"odk-workflows/ReleaseWorkflow/#run-a-release-with-the-odk","text":"Preparation: Ensure that all your pull requests are merged into your main (master) branch Make sure that all changes to master are committed to GitHub ( git status should say that there are no modified files) Locally make sure you have the latest changes from master ( git pull ) Checkout a new branch (e.g. git checkout -b release-2021-01-01 ) You may or may not want to refresh your imports as part of your release strategy (see here ) Make sure you have the latest ODK installed by running docker pull obolibrary/odkfull To actually run the release, you: Open a command line terminal window and navigate to the src/ontology directory ( cd cl/src/ontology ) Run release pipeline: sh run.sh make prepare_release -B . Note that for some ontologies, this process can take up to 90 minutes - especially if there are large ontologies you depend on, like PRO or CHEBI. If everything went well, you should see the following output on your machine: Release files are now in ../.. - now you should commit, push and make a release on your git hosting site such as GitHub or GitLab . This will create all the specified release targets (OBO, OWL, JSON, and the variants, ont-full and ont-base) and copy them into your release directory (the top level of your repo).","title":"Run a release with the ODK"},{"location":"odk-workflows/ReleaseWorkflow/#review-the-release","text":"(Optional) Rough check. This step is frequently skipped, but for the more paranoid among us (like the author of this doc), this is a 3 minute additional effort for some peace of mind. Open the main release (cl.owl) in you favourite development environment (i.e. Prot\u00e9g\u00e9) and eyeball the hierarchy. We recommend two simple checks: Does the very top level of the hierarchy look ok? This means that all new terms have been imported/updated correctly. Does at least one change that you know should be in this release appear? For example, a new class. This means that the release was actually based on the recent edit file. Commit your changes to the branch and make a pull request In your GitHub pull request, review the following three files in detail (based on our experience): cl.obo - this reflects a useful subset of the whole ontology (everything that can be covered by OBO format). OBO format has that speaking for it: it is very easy to review! cl-base.owl - this reflects the asserted axioms in your ontology that you have actually edited. Ideally also take a look at cl-full.owl , which may reveal interesting new inferences you did not know about. Note that the diff of this file is sometimes quite large. Like with every pull request, we recommend to always employ a second set of eyes when reviewing a PR!","title":"Review the release"},{"location":"odk-workflows/ReleaseWorkflow/#merge-the-main-branch","text":"Once your CI checks have passed, and your reviews are completed, you can now merge the branch into your main branch (don't forget to delete the branch afterwards - a big button will appear after the merge is finished).","title":"Merge the main branch"},{"location":"odk-workflows/ReleaseWorkflow/#create-a-github-release","text":"Go to your releases page on GitHub by navigating to your repository, and then clicking on releases (usually on the right, for example: https://github.com/obophenotype/cell-ontology/releases). Then click \"Draft new release\" As the tag version you need to choose the date on which your ontologies were build. You can find this, for example, by looking at the cl.obo file and check the data-version: property. The date needs to be prefixed with a v , so, for example v2020-02-06 . You can write whatever you want in the release title, but we typically write the date again. The description underneath should contain a concise list of changes or term additions. Click \"Publish release\". Done.","title":"Create a GitHub release"},{"location":"odk-workflows/ReleaseWorkflow/#debugging-typical-ontology-release-problems","text":"","title":"Debugging typical ontology release problems"},{"location":"odk-workflows/ReleaseWorkflow/#problems-with-memory","text":"When you are dealing with large ontologies, you need a lot of memory. When you see error messages relating to large ontologies such as CHEBI, PRO, NCBITAXON, or Uberon, you should think of memory first, see here .","title":"Problems with memory"},{"location":"odk-workflows/ReleaseWorkflow/#problems-when-using-obo-format-based-tools","text":"Sometimes you will get cryptic error messages when using legacy tools using OBO format, such as the ontology release tool (OORT), which is also available as part of the ODK docker container. In these cases, you need to track down what axiom or annotation actually caused the breakdown. In our experience (in about 60% of the cases) the problem lies with duplicate annotations ( def , comment ) which are illegal in OBO. Here is an example recipe of how to deal with such a problem: If you get a message like make: *** [cl.Makefile:84: oort] Error 255 you might have a OORT error. To debug this, in your terminal enter sh run.sh make IMP=false PAT=false oort -B (assuming you are already in the ontology folder in your directory) This should show you where the error is in the log (eg multiple different definitions) WARNING: THE FIX BELOW IS NOT IDEAL, YOU SHOULD ALWAYS TRY TO FIX UPSTREAM IF POSSIBLE Open cl-edit.owl in Prot\u00e9g\u00e9 and find the offending term and delete all offending issue (e.g. delete ALL definition, if the problem was \"multiple def tags not allowed\") and save. *While this is not idea, as it will remove all definitions from that term, it will be added back again when the term is fixed in the ontology it was imported from and added back in. Rerun sh run.sh make IMP=false PAT=false oort -B and if it all passes, commit your changes to a branch and make a pull request as usual.","title":"Problems when using OBO format based tools"},{"location":"odk-workflows/RepoManagement/","text":"Managing your ODK repository \u00b6 Updating your ODK repository \u00b6 Your ODK repositories configuration is managed in src/ontology/cl-odk.yaml . The ODK Project Configuration Schema defines all possible parameters that can be used in this config YAML. Once you have made your changes, you can run the following to apply your changes to the repository: sh run.sh make update_repo There are a large number of options that can be set to configure your ODK, but we will only discuss a few of them here. NOTE for Windows users: You may get a cryptic failure such as Set Illegal Option - if the update script located in src/scripts/update_repo.sh was saved using Windows Line endings. These need to change to unix line endings. In Notepad++, for example, you can click on Edit->EOL Conversion->Unix LF to change this. Managing imports \u00b6 You can use the update repository workflow described on this page to perform the following operations to your imports: Add a new import Modify an existing import Remove an import you no longer want Customise an import We will discuss all these workflows in the following. Add new import \u00b6 To add a new import, you first edit your odk config as described above , adding an id to the product list in the import_group section (for the sake of this example, we assume you already import RO, and your goal is to also import GO): import_group: products: - id: ro - id: go Note: our ODK file should only have one import_group which can contain multiple imports (in the products section). Next, you run the update repo workflow to apply these changes. Note that by default, this module is going to be a SLME Bottom module, see here . To change that or customise your module, see section \"Customise an import\". To finalise the addition of your import, perform the following steps: Add an import statement to your src/ontology/cl-edit.owl file. We suggest to do this using a text editor, by simply copying an existing import declaration and renaming it to the new ontology import, for example as follows: ... Ontology(<http://purl.obolibrary.org/obo/cl.owl> Import(<http://purl.obolibrary.org/obo/cl/imports/ro_import.owl>) Import(<http://purl.obolibrary.org/obo/cl/imports/go_import.owl>) ... Add your imports redirect to your catalog file src/ontology/catalog-v001.xml , for example: <uri name=\"http://purl.obolibrary.org/obo/cl/imports/go_import.owl\" uri=\"imports/go_import.owl\"/> Test whether everything is in order: Refresh your import Open in your Ontology Editor of choice (Protege) and ensure that the expected terms are imported. Note: The catalog file src/ontology/catalog-v001.xml has one purpose: redirecting imports from URLs to local files. For example, if you have Import(<http://purl.obolibrary.org/obo/cl/imports/go_import.owl>) in your editors file (the ontology) and <uri name=\"http://purl.obolibrary.org/obo/cl/imports/go_import.owl\" uri=\"imports/go_import.owl\"/> in your catalog, tools like robot or Prot\u00e9g\u00e9 will recognize the statement in the catalog file to redirect the URL http://purl.obolibrary.org/obo/cl/imports/go_import.owl to the local file imports/go_import.owl (which is in your src/ontology directory). Modify an existing import \u00b6 If you simply wish to refresh your import in light of new terms, see here . If you wish to change the type of your module see section \"Customise an import\". Remove an existing import \u00b6 To remove an existing import, perform the following steps: remove the import declaration from your src/ontology/cl-edit.owl . remove the id from your src/ontology/cl-odk.yaml , eg. - id: go from the list of products in the import_group . run update repo workflow delete the associated files manually: src/imports/go_import.owl src/imports/go_terms.txt Remove the respective entry from the src/ontology/catalog-v001.xml file. Customise an import \u00b6 By default, an import module extracted from a source ontology will be a SLME module, see here . There are various options to change the default. The following change to your repo config ( src/ontology/cl-odk.yaml ) will switch the go import from an SLME module to a simple ROBOT filter module: import_group: products: - id: ro - id: go module_type: filter A ROBOT filter module is, essentially, importing all external terms declared by your ontology (see here on how to declare external terms to be imported). Note that the filter module does not consider terms/annotations from namespaces other than the base-namespace of the ontology itself. For example, in the example of GO above, only annotations / axioms related to the GO base IRI (http://purl.obolibrary.org/obo/GO_) would be considered. This behaviour can be changed by adding additional base IRIs as follows: import_group: products: - id: go module_type: filter base_iris: - http://purl.obolibrary.org/obo/GO_ - http://purl.obolibrary.org/obo/CL_ - http://purl.obolibrary.org/obo/BFO If you wish to customise your import entirely, you can specify your own ROBOT command to do so. To do that, add the following to your repo config ( src/ontology/cl-odk.yaml ): import_group: products: - id: ro - id: go module_type: custom Now add a new goal in your custom Makefile ( src/ontology/cl.Makefile , not src/ontology/Makefile ). imports/go_import.owl: mirror/ro.owl imports/ro_terms_combined.txt if [ $(IMP) = true ]; then $(ROBOT) query -i $< --update ../sparql/preprocess-module.ru \\ extract -T imports/ro_terms_combined.txt --force true --individuals exclude --method BOT \\ query --update ../sparql/inject-subset-declaration.ru --update ../sparql/postprocess-module.ru \\ annotate --ontology-iri $(ONTBASE)/$@ $(ANNOTATE_ONTOLOGY_VERSION) --output $@.tmp.owl && mv $@.tmp.owl $@; fi Now feel free to change this goal to do whatever you wish it to do! It probably makes some sense (albeit not being a strict necessity), to leave most of the goal instead and replace only: extract -T imports/ro_terms_combined.txt --force true --individuals exclude --method BOT \\ to another ROBOT pipeline. Add a component \u00b6 A component is an import which belongs to your ontology, e.g. is managed by you and your team. Open src/ontology/cl-odk.yaml If you dont have it yet, add a new top level section components Under the components section, add a new section called products . This is where all your components are specified Under the products section, add a new component, e.g. - filename: mycomp.owl Example components: products: - filename: mycomp.owl When running sh run.sh make update_repo , a new file src/ontology/components/mycomp.owl will be created which you can edit as you see fit. Typical ways to edit: Using a ROBOT template to generate the component (see below) Manually curating the component separately with Prot\u00e9g\u00e9 or any other editor Providing a components/mycomp.owl: make target in src/ontology/cl.Makefile and provide a custom command to generate the component WARNING : Note that the custom rule to generate the component MUST NOT depend on any other ODK-generated file such as seed files and the like (see issue ). Providing an additional attribute for the component in src/ontology/cl-odk.yaml , source , to specify that this component should simply be downloaded from somewhere on the web. Adding a new component based on a ROBOT template \u00b6 Since ODK 1.3.2, it is possible to simply link a ROBOT template to a component without having to specify any of the import logic. In order to add a new component that is connected to one or more template files, follow these steps: Open src/ontology/cl-odk.yaml . Make sure that use_templates: TRUE is set in the global project options. You should also make sure that use_context: TRUE is set in case you are using prefixes in your templates that are not known to robot , such as OMOP: , CPONT: and more. All non-standard prefixes you are using should be added to config/context.json . Add another component to the products section. To activate this component to be template-driven, simply say: use_template: TRUE . This will create an empty template for you in the templates directory, which will automatically be processed when recreating the component (e.g. run.bat make recreate-mycomp ). If you want to use more than one component, use the templates field to add as many template names as you wish. ODK will look for them in the src/templates directory. Advanced: If you want to provide additional processing options, you can use the template_options field. This should be a string with option from robot template . One typical example for additional options you may want to provide is --add-prefixes config/context.json to ensure the prefix map of your context is provided to robot , see above. Example : components: products: - filename: mycomp.owl use_template: TRUE template_options: --add-prefixes config/context.json templates: - template1.tsv - template2.tsv Note : if your mirror is particularly large and complex, read this ODK recommendation .","title":"Manage your ODK Repository"},{"location":"odk-workflows/RepoManagement/#managing-your-odk-repository","text":"","title":"Managing your ODK repository"},{"location":"odk-workflows/RepoManagement/#updating-your-odk-repository","text":"Your ODK repositories configuration is managed in src/ontology/cl-odk.yaml . The ODK Project Configuration Schema defines all possible parameters that can be used in this config YAML. Once you have made your changes, you can run the following to apply your changes to the repository: sh run.sh make update_repo There are a large number of options that can be set to configure your ODK, but we will only discuss a few of them here. NOTE for Windows users: You may get a cryptic failure such as Set Illegal Option - if the update script located in src/scripts/update_repo.sh was saved using Windows Line endings. These need to change to unix line endings. In Notepad++, for example, you can click on Edit->EOL Conversion->Unix LF to change this.","title":"Updating your ODK repository"},{"location":"odk-workflows/RepoManagement/#managing-imports","text":"You can use the update repository workflow described on this page to perform the following operations to your imports: Add a new import Modify an existing import Remove an import you no longer want Customise an import We will discuss all these workflows in the following.","title":"Managing imports"},{"location":"odk-workflows/RepoManagement/#add-new-import","text":"To add a new import, you first edit your odk config as described above , adding an id to the product list in the import_group section (for the sake of this example, we assume you already import RO, and your goal is to also import GO): import_group: products: - id: ro - id: go Note: our ODK file should only have one import_group which can contain multiple imports (in the products section). Next, you run the update repo workflow to apply these changes. Note that by default, this module is going to be a SLME Bottom module, see here . To change that or customise your module, see section \"Customise an import\". To finalise the addition of your import, perform the following steps: Add an import statement to your src/ontology/cl-edit.owl file. We suggest to do this using a text editor, by simply copying an existing import declaration and renaming it to the new ontology import, for example as follows: ... Ontology(<http://purl.obolibrary.org/obo/cl.owl> Import(<http://purl.obolibrary.org/obo/cl/imports/ro_import.owl>) Import(<http://purl.obolibrary.org/obo/cl/imports/go_import.owl>) ... Add your imports redirect to your catalog file src/ontology/catalog-v001.xml , for example: <uri name=\"http://purl.obolibrary.org/obo/cl/imports/go_import.owl\" uri=\"imports/go_import.owl\"/> Test whether everything is in order: Refresh your import Open in your Ontology Editor of choice (Protege) and ensure that the expected terms are imported. Note: The catalog file src/ontology/catalog-v001.xml has one purpose: redirecting imports from URLs to local files. For example, if you have Import(<http://purl.obolibrary.org/obo/cl/imports/go_import.owl>) in your editors file (the ontology) and <uri name=\"http://purl.obolibrary.org/obo/cl/imports/go_import.owl\" uri=\"imports/go_import.owl\"/> in your catalog, tools like robot or Prot\u00e9g\u00e9 will recognize the statement in the catalog file to redirect the URL http://purl.obolibrary.org/obo/cl/imports/go_import.owl to the local file imports/go_import.owl (which is in your src/ontology directory).","title":"Add new import"},{"location":"odk-workflows/RepoManagement/#modify-an-existing-import","text":"If you simply wish to refresh your import in light of new terms, see here . If you wish to change the type of your module see section \"Customise an import\".","title":"Modify an existing import"},{"location":"odk-workflows/RepoManagement/#remove-an-existing-import","text":"To remove an existing import, perform the following steps: remove the import declaration from your src/ontology/cl-edit.owl . remove the id from your src/ontology/cl-odk.yaml , eg. - id: go from the list of products in the import_group . run update repo workflow delete the associated files manually: src/imports/go_import.owl src/imports/go_terms.txt Remove the respective entry from the src/ontology/catalog-v001.xml file.","title":"Remove an existing import"},{"location":"odk-workflows/RepoManagement/#customise-an-import","text":"By default, an import module extracted from a source ontology will be a SLME module, see here . There are various options to change the default. The following change to your repo config ( src/ontology/cl-odk.yaml ) will switch the go import from an SLME module to a simple ROBOT filter module: import_group: products: - id: ro - id: go module_type: filter A ROBOT filter module is, essentially, importing all external terms declared by your ontology (see here on how to declare external terms to be imported). Note that the filter module does not consider terms/annotations from namespaces other than the base-namespace of the ontology itself. For example, in the example of GO above, only annotations / axioms related to the GO base IRI (http://purl.obolibrary.org/obo/GO_) would be considered. This behaviour can be changed by adding additional base IRIs as follows: import_group: products: - id: go module_type: filter base_iris: - http://purl.obolibrary.org/obo/GO_ - http://purl.obolibrary.org/obo/CL_ - http://purl.obolibrary.org/obo/BFO If you wish to customise your import entirely, you can specify your own ROBOT command to do so. To do that, add the following to your repo config ( src/ontology/cl-odk.yaml ): import_group: products: - id: ro - id: go module_type: custom Now add a new goal in your custom Makefile ( src/ontology/cl.Makefile , not src/ontology/Makefile ). imports/go_import.owl: mirror/ro.owl imports/ro_terms_combined.txt if [ $(IMP) = true ]; then $(ROBOT) query -i $< --update ../sparql/preprocess-module.ru \\ extract -T imports/ro_terms_combined.txt --force true --individuals exclude --method BOT \\ query --update ../sparql/inject-subset-declaration.ru --update ../sparql/postprocess-module.ru \\ annotate --ontology-iri $(ONTBASE)/$@ $(ANNOTATE_ONTOLOGY_VERSION) --output $@.tmp.owl && mv $@.tmp.owl $@; fi Now feel free to change this goal to do whatever you wish it to do! It probably makes some sense (albeit not being a strict necessity), to leave most of the goal instead and replace only: extract -T imports/ro_terms_combined.txt --force true --individuals exclude --method BOT \\ to another ROBOT pipeline.","title":"Customise an import"},{"location":"odk-workflows/RepoManagement/#add-a-component","text":"A component is an import which belongs to your ontology, e.g. is managed by you and your team. Open src/ontology/cl-odk.yaml If you dont have it yet, add a new top level section components Under the components section, add a new section called products . This is where all your components are specified Under the products section, add a new component, e.g. - filename: mycomp.owl Example components: products: - filename: mycomp.owl When running sh run.sh make update_repo , a new file src/ontology/components/mycomp.owl will be created which you can edit as you see fit. Typical ways to edit: Using a ROBOT template to generate the component (see below) Manually curating the component separately with Prot\u00e9g\u00e9 or any other editor Providing a components/mycomp.owl: make target in src/ontology/cl.Makefile and provide a custom command to generate the component WARNING : Note that the custom rule to generate the component MUST NOT depend on any other ODK-generated file such as seed files and the like (see issue ). Providing an additional attribute for the component in src/ontology/cl-odk.yaml , source , to specify that this component should simply be downloaded from somewhere on the web.","title":"Add a component"},{"location":"odk-workflows/RepoManagement/#adding-a-new-component-based-on-a-robot-template","text":"Since ODK 1.3.2, it is possible to simply link a ROBOT template to a component without having to specify any of the import logic. In order to add a new component that is connected to one or more template files, follow these steps: Open src/ontology/cl-odk.yaml . Make sure that use_templates: TRUE is set in the global project options. You should also make sure that use_context: TRUE is set in case you are using prefixes in your templates that are not known to robot , such as OMOP: , CPONT: and more. All non-standard prefixes you are using should be added to config/context.json . Add another component to the products section. To activate this component to be template-driven, simply say: use_template: TRUE . This will create an empty template for you in the templates directory, which will automatically be processed when recreating the component (e.g. run.bat make recreate-mycomp ). If you want to use more than one component, use the templates field to add as many template names as you wish. ODK will look for them in the src/templates directory. Advanced: If you want to provide additional processing options, you can use the template_options field. This should be a string with option from robot template . One typical example for additional options you may want to provide is --add-prefixes config/context.json to ensure the prefix map of your context is provided to robot , see above. Example : components: products: - filename: mycomp.owl use_template: TRUE template_options: --add-prefixes config/context.json templates: - template1.tsv - template2.tsv Note : if your mirror is particularly large and complex, read this ODK recommendation .","title":"Adding a new component based on a ROBOT template"},{"location":"odk-workflows/RepositoryFileStructure/","text":"Repository structure \u00b6 The main kinds of files in the repository: Release files Imports Components Release files \u00b6 Release file are the file that are considered part of the official ontology release and to be used by the community. A detailed description of the release artefacts can be found here . Imports \u00b6 Imports are subsets of external ontologies that contain terms and axioms you would like to re-use in your ontology. These are considered \"external\", like dependencies in software development, and are not included in your \"base\" product, which is the release artefact which contains only those axioms that you personally maintain. These are the current imports in CL Import URL Type pr https://raw.githubusercontent.com/obophenotype/pro_obo_slim/master/pr_slim.owl slme go http://purl.obolibrary.org/obo/go.owl slme uberon http://purl.obolibrary.org/obo/uberon.owl slme ro http://purl.obolibrary.org/obo/ro.owl slme pato http://purl.obolibrary.org/obo/pato.owl slme ncbitaxon http://purl.obolibrary.org/obo/ncbitaxon/subsets/taxslim.owl slme ncbitaxondisjoints http://purl.obolibrary.org/obo/ncbitaxon/subsets/taxslim-disjoint-over-in-taxon.owl slme omo http://purl.obolibrary.org/obo/omo.owl mirror mbao https://raw.githubusercontent.com/brain-bican/mouse_brain_atlas_ontology/main/mbao-base.owl slme stato http://purl.obolibrary.org/obo/stato.owl slme ## Components Components, in contrast to imports, are considered full members of the ontology. This means that any axiom in a component is also included in the ontology base - which means it is considered native to the ontology. While this sounds complicated, consider this: conceptually, no component should be part of more than one ontology. If that seems to be the case, we are most likely talking about an import. Components are often not needed for ontologies, but there are some use cases: There is an automated process that generates and re-generates a part of the ontology A part of the ontology is managed in ROBOT templates The expressivity of the component is higher than the format of the edit file. For example, people still choose to manage their ontology in OBO format (they should not) missing out on a lot of owl features. They may choose to manage logic that is beyond OBO in a specific OWL component. These are the components in CL Filename URL hra_subset.owl https://raw.githubusercontent.com/hubmapconsortium/ccf-validation-tools/master/owl/CL_ASCTB_subset.owl mappings.owl None blood_and_immune_upper_slim.owl None eye_upper_slim.owl None general_cell_types_upper_slim.owl None kidney_upper_slim.owl None cellxgene_subset.owl None PNS_neurons.owl None clm-cl.owl https://raw.githubusercontent.com/Cellular-Semantics/CellMark/main/clm-cl.owl 2DFTU_HRA_illustrations.owl None wmbo-cl-comp.owl https://raw.githubusercontent.com/Cellular-Semantics/whole_mouse_brain_ontology/main/wmbo-cl-comp.owl","title":"Your ODK Repository Overview"},{"location":"odk-workflows/RepositoryFileStructure/#repository-structure","text":"The main kinds of files in the repository: Release files Imports Components","title":"Repository structure"},{"location":"odk-workflows/RepositoryFileStructure/#release-files","text":"Release file are the file that are considered part of the official ontology release and to be used by the community. A detailed description of the release artefacts can be found here .","title":"Release files"},{"location":"odk-workflows/RepositoryFileStructure/#imports","text":"Imports are subsets of external ontologies that contain terms and axioms you would like to re-use in your ontology. These are considered \"external\", like dependencies in software development, and are not included in your \"base\" product, which is the release artefact which contains only those axioms that you personally maintain. These are the current imports in CL Import URL Type pr https://raw.githubusercontent.com/obophenotype/pro_obo_slim/master/pr_slim.owl slme go http://purl.obolibrary.org/obo/go.owl slme uberon http://purl.obolibrary.org/obo/uberon.owl slme ro http://purl.obolibrary.org/obo/ro.owl slme pato http://purl.obolibrary.org/obo/pato.owl slme ncbitaxon http://purl.obolibrary.org/obo/ncbitaxon/subsets/taxslim.owl slme ncbitaxondisjoints http://purl.obolibrary.org/obo/ncbitaxon/subsets/taxslim-disjoint-over-in-taxon.owl slme omo http://purl.obolibrary.org/obo/omo.owl mirror mbao https://raw.githubusercontent.com/brain-bican/mouse_brain_atlas_ontology/main/mbao-base.owl slme stato http://purl.obolibrary.org/obo/stato.owl slme ## Components Components, in contrast to imports, are considered full members of the ontology. This means that any axiom in a component is also included in the ontology base - which means it is considered native to the ontology. While this sounds complicated, consider this: conceptually, no component should be part of more than one ontology. If that seems to be the case, we are most likely talking about an import. Components are often not needed for ontologies, but there are some use cases: There is an automated process that generates and re-generates a part of the ontology A part of the ontology is managed in ROBOT templates The expressivity of the component is higher than the format of the edit file. For example, people still choose to manage their ontology in OBO format (they should not) missing out on a lot of owl features. They may choose to manage logic that is beyond OBO in a specific OWL component. These are the components in CL Filename URL hra_subset.owl https://raw.githubusercontent.com/hubmapconsortium/ccf-validation-tools/master/owl/CL_ASCTB_subset.owl mappings.owl None blood_and_immune_upper_slim.owl None eye_upper_slim.owl None general_cell_types_upper_slim.owl None kidney_upper_slim.owl None cellxgene_subset.owl None PNS_neurons.owl None clm-cl.owl https://raw.githubusercontent.com/Cellular-Semantics/CellMark/main/clm-cl.owl 2DFTU_HRA_illustrations.owl None wmbo-cl-comp.owl https://raw.githubusercontent.com/Cellular-Semantics/whole_mouse_brain_ontology/main/wmbo-cl-comp.owl","title":"Imports"},{"location":"odk-workflows/SettingUpDockerForODK/","text":"Setting up your Docker environment for ODK use \u00b6 One of the most frequent problems with running the ODK for the first time is failure because of lack of memory. This can look like a Java OutOfMemory exception, but more often than not it will appear as something like an Error 137 . There are two places you need to consider to set your memory: Your src/ontology/run.sh (or run.bat) file. You can set the memory in there by adding robot_java_args: '-Xmx8G' to your src/ontology/cl-odk.yaml file, see for example here . Set your docker memory. By default, it should be about 10-20% more than your robot_java_args variable. You can manage your memory settings by right-clicking on the docker whale in your system bar-->Preferences-->Resources-->Advanced, see picture below.","title":"Setting up Docker for ODK"},{"location":"odk-workflows/SettingUpDockerForODK/#setting-up-your-docker-environment-for-odk-use","text":"One of the most frequent problems with running the ODK for the first time is failure because of lack of memory. This can look like a Java OutOfMemory exception, but more often than not it will appear as something like an Error 137 . There are two places you need to consider to set your memory: Your src/ontology/run.sh (or run.bat) file. You can set the memory in there by adding robot_java_args: '-Xmx8G' to your src/ontology/cl-odk.yaml file, see for example here . Set your docker memory. By default, it should be about 10-20% more than your robot_java_args variable. You can manage your memory settings by right-clicking on the docker whale in your system bar-->Preferences-->Resources-->Advanced, see picture below.","title":"Setting up your Docker environment for ODK use"},{"location":"odk-workflows/UpdateImports/","text":"Update Imports Workflow \u00b6 This page discusses how to update the contents of your imports, like adding or removing terms. If you are looking to customise imports, like changing the module type, see here . Importing a new term \u00b6 Note: some ontologies now use a merged-import system to manage dynamic imports, for these please follow instructions in the section title \"Using the Base Module approach\". Importing a new term is split into two sub-phases: Declaring the terms to be imported Refreshing imports dynamically Declaring terms to be imported \u00b6 There are three ways to declare terms that are to be imported from an external ontology. Choose the appropriate one for your particular scenario (all three can be used in parallel if need be): Prot\u00e9g\u00e9-based declaration Using term files Using the custom import template Prot\u00e9g\u00e9-based declaration \u00b6 This workflow is to be avoided, but may be appropriate if the editor does not have access to the ODK docker container . This approach also applies to ontologies that use base module import approach. Open your ontology (edit file) in Prot\u00e9g\u00e9 (5.5+). Select 'owl:Thing' Add a new class as usual. Paste the full iri in the 'Name:' field, for example, http://purl.obolibrary.org/obo/CHEBI_50906. Click 'OK' Now you can use this term for example to construct logical definitions. The next time the imports are refreshed (see how to refresh here ), the metadata (labels, definitions, etc.) for this term are imported from the respective external source ontology and becomes visible in your ontology. Using term files \u00b6 Every import has, by default a term file associated with it, which can be found in the imports directory. For example, if you have a GO import in src/ontology/go_import.owl , you will also have an associated term file src/ontology/go_terms.txt . You can add terms in there simply as a list: GO:0008150 GO:0008151 Now you can run the refresh imports workflow ) and the two terms will be imported. Using the custom import template \u00b6 This workflow is appropriate if: You prefer to manage all your imported terms in a single file (rather than multiple files like in the \"Using term files\" workflow above). You wish to augment your imported ontologies with additional information. This requires a cautionary discussion. To enable this workflow, you add the following to your ODK config file ( src/ontology/cl-odk.yaml ), and update the repository : use_custom_import_module: TRUE Now you can manage your imported terms directly in the custom external terms template, which is located at src/templates/external_import.owl . Note that this file is a ROBOT template , and can, in principle, be extended to include any axioms you like. Before extending the template, however, read the following carefully. The main purpose of the custom import template is to enable the management off all terms to be imported in a centralised place. To enable that, you do not have to do anything other than maintaining the template. So if you, say currently import APOLLO_SV:00000480 , and you wish to import APOLLO_SV:00000532 , you simply add a row like this: ID Entity Type ID TYPE APOLLO_SV:00000480 owl:Class APOLLO_SV:00000532 owl:Class When the imports are refreshed see imports refresh workflow , the term(s) will simply be imported from the configured ontologies. Now, if you wish to extend the Makefile (which is beyond these instructions) and add, say, synonyms to the imported terms, you can do that, but you need to (a) preserve the ID and ENTITY columns and (b) ensure that the ROBOT template is valid otherwise, see here . WARNING . Note that doing this is a widespread antipattern (see related issue ). You should not change the axioms of terms that do not belong into your ontology unless necessary - such changes should always be pushed into the ontology where they belong. However, since people are doing it, whether the OBO Foundry likes it or not, at least using the custom imports module as described here localises the changes to a single simple template and ensures that none of the annotations added this way are merged into the base file . Refresh imports \u00b6 If you want to refresh the import yourself (this may be necessary to pass the travis tests), and you have the ODK installed, you can do the following (using go as an example): First, you navigate in your terminal to the ontology directory (underneath src in your hpo root directory). cd src/ontology Then, you regenerate the import that will now include any new terms you have added. Note: You must have docker installed . sh run.sh make PAT=false imports/go_import.owl -B Since ODK 1.2.27, it is also possible to simply run the following, which is the same as the above: sh run.sh make refresh-go Note that in case you changed the defaults, you need to add IMP=true and/or MIR=true to the command below: sh run.sh make IMP=true MIR=true PAT=false imports/go_import.owl -B If you wish to skip refreshing the mirror, i.e. skip downloading the latest version of the source ontology for your import (e.g. go.owl for your go import) you can set MIR=false instead, which will do the exact same thing as the above, but is easier to remember: sh run.sh make IMP=true MIR=false PAT=false imports/go_import.owl -B Using the Base Module approach \u00b6 Since ODK 1.2.31, we support an entirely new approach to generate modules: Using base files. The idea is to only import axioms from ontologies that actually belong to it . A base file is a subset of the ontology that only contains those axioms that nominally belong there. In other words, the base file does not contain any axioms that belong to another ontology. An example would be this: Imagine this being the full Uberon ontology: Axiom 1: BFO:123 SubClassOf BFO:124 Axiom 1: UBERON:123 SubClassOf BFO:123 Axiom 1: UBERON:124 SubClassOf UBERON 123 The base file is the set of all axioms that are about UBERON terms: Axiom 1: UBERON:123 SubClassOf BFO:123 Axiom 1: UBERON:124 SubClassOf UBERON 123 I.e. Axiom 1: BFO:123 SubClassOf BFO:124 Gets removed. The base file pipeline is a bit more complex than the normal pipelines, because of the logical interactions between the imported ontologies. This is solved by _first merging all mirrors into one huge file and then extracting one mega module from it. Example: Let's say we are importing terms from Uberon, GO and RO in our ontologies. When we use the base pipelines, we 1) First obtain the base (usually by simply downloading it, but there is also an option now to create it with ROBOT) 2) We merge all base files into one big pile 3) Then we extract a single module imports/merged_import.owl The first implementation of this pipeline is PATO, see https://github.com/pato-ontology/pato/blob/master/src/ontology/pato-odk.yaml. To check if your ontology uses this method, check src/ontology/cl-odk.yaml to see if use_base_merging: TRUE is declared under import_group If your ontology uses Base Module approach, please use the following steps: First, add the term to be imported to the term file associated with it (see above \"Using term files\" section if this is not clear to you) Next, you navigate in your terminal to the ontology directory (underneath src in your hpo root directory). cd src/ontology Then refresh imports by running sh run.sh make imports/merged_import.owl Note: if your mirrors are updated, you can run sh run.sh make no-mirror-refresh-merged This requires quite a bit of memory on your local machine, so if you encounter an error, it might be a lack of memory on your computer. A solution would be to create a ticket in an issue tracker requesting for the term to be imported, and one of the local devs should pick this up and run the import for you. Lastly, restart Prot\u00e9g\u00e9, and the term should be imported in ready to be used.","title":"Imports management"},{"location":"odk-workflows/UpdateImports/#update-imports-workflow","text":"This page discusses how to update the contents of your imports, like adding or removing terms. If you are looking to customise imports, like changing the module type, see here .","title":"Update Imports Workflow"},{"location":"odk-workflows/UpdateImports/#importing-a-new-term","text":"Note: some ontologies now use a merged-import system to manage dynamic imports, for these please follow instructions in the section title \"Using the Base Module approach\". Importing a new term is split into two sub-phases: Declaring the terms to be imported Refreshing imports dynamically","title":"Importing a new term"},{"location":"odk-workflows/UpdateImports/#declaring-terms-to-be-imported","text":"There are three ways to declare terms that are to be imported from an external ontology. Choose the appropriate one for your particular scenario (all three can be used in parallel if need be): Prot\u00e9g\u00e9-based declaration Using term files Using the custom import template","title":"Declaring terms to be imported"},{"location":"odk-workflows/UpdateImports/#protege-based-declaration","text":"This workflow is to be avoided, but may be appropriate if the editor does not have access to the ODK docker container . This approach also applies to ontologies that use base module import approach. Open your ontology (edit file) in Prot\u00e9g\u00e9 (5.5+). Select 'owl:Thing' Add a new class as usual. Paste the full iri in the 'Name:' field, for example, http://purl.obolibrary.org/obo/CHEBI_50906. Click 'OK' Now you can use this term for example to construct logical definitions. The next time the imports are refreshed (see how to refresh here ), the metadata (labels, definitions, etc.) for this term are imported from the respective external source ontology and becomes visible in your ontology.","title":"Prot\u00e9g\u00e9-based declaration"},{"location":"odk-workflows/UpdateImports/#using-term-files","text":"Every import has, by default a term file associated with it, which can be found in the imports directory. For example, if you have a GO import in src/ontology/go_import.owl , you will also have an associated term file src/ontology/go_terms.txt . You can add terms in there simply as a list: GO:0008150 GO:0008151 Now you can run the refresh imports workflow ) and the two terms will be imported.","title":"Using term files"},{"location":"odk-workflows/UpdateImports/#using-the-custom-import-template","text":"This workflow is appropriate if: You prefer to manage all your imported terms in a single file (rather than multiple files like in the \"Using term files\" workflow above). You wish to augment your imported ontologies with additional information. This requires a cautionary discussion. To enable this workflow, you add the following to your ODK config file ( src/ontology/cl-odk.yaml ), and update the repository : use_custom_import_module: TRUE Now you can manage your imported terms directly in the custom external terms template, which is located at src/templates/external_import.owl . Note that this file is a ROBOT template , and can, in principle, be extended to include any axioms you like. Before extending the template, however, read the following carefully. The main purpose of the custom import template is to enable the management off all terms to be imported in a centralised place. To enable that, you do not have to do anything other than maintaining the template. So if you, say currently import APOLLO_SV:00000480 , and you wish to import APOLLO_SV:00000532 , you simply add a row like this: ID Entity Type ID TYPE APOLLO_SV:00000480 owl:Class APOLLO_SV:00000532 owl:Class When the imports are refreshed see imports refresh workflow , the term(s) will simply be imported from the configured ontologies. Now, if you wish to extend the Makefile (which is beyond these instructions) and add, say, synonyms to the imported terms, you can do that, but you need to (a) preserve the ID and ENTITY columns and (b) ensure that the ROBOT template is valid otherwise, see here . WARNING . Note that doing this is a widespread antipattern (see related issue ). You should not change the axioms of terms that do not belong into your ontology unless necessary - such changes should always be pushed into the ontology where they belong. However, since people are doing it, whether the OBO Foundry likes it or not, at least using the custom imports module as described here localises the changes to a single simple template and ensures that none of the annotations added this way are merged into the base file .","title":"Using the custom import template"},{"location":"odk-workflows/UpdateImports/#refresh-imports","text":"If you want to refresh the import yourself (this may be necessary to pass the travis tests), and you have the ODK installed, you can do the following (using go as an example): First, you navigate in your terminal to the ontology directory (underneath src in your hpo root directory). cd src/ontology Then, you regenerate the import that will now include any new terms you have added. Note: You must have docker installed . sh run.sh make PAT=false imports/go_import.owl -B Since ODK 1.2.27, it is also possible to simply run the following, which is the same as the above: sh run.sh make refresh-go Note that in case you changed the defaults, you need to add IMP=true and/or MIR=true to the command below: sh run.sh make IMP=true MIR=true PAT=false imports/go_import.owl -B If you wish to skip refreshing the mirror, i.e. skip downloading the latest version of the source ontology for your import (e.g. go.owl for your go import) you can set MIR=false instead, which will do the exact same thing as the above, but is easier to remember: sh run.sh make IMP=true MIR=false PAT=false imports/go_import.owl -B","title":"Refresh imports"},{"location":"odk-workflows/UpdateImports/#using-the-base-module-approach","text":"Since ODK 1.2.31, we support an entirely new approach to generate modules: Using base files. The idea is to only import axioms from ontologies that actually belong to it . A base file is a subset of the ontology that only contains those axioms that nominally belong there. In other words, the base file does not contain any axioms that belong to another ontology. An example would be this: Imagine this being the full Uberon ontology: Axiom 1: BFO:123 SubClassOf BFO:124 Axiom 1: UBERON:123 SubClassOf BFO:123 Axiom 1: UBERON:124 SubClassOf UBERON 123 The base file is the set of all axioms that are about UBERON terms: Axiom 1: UBERON:123 SubClassOf BFO:123 Axiom 1: UBERON:124 SubClassOf UBERON 123 I.e. Axiom 1: BFO:123 SubClassOf BFO:124 Gets removed. The base file pipeline is a bit more complex than the normal pipelines, because of the logical interactions between the imported ontologies. This is solved by _first merging all mirrors into one huge file and then extracting one mega module from it. Example: Let's say we are importing terms from Uberon, GO and RO in our ontologies. When we use the base pipelines, we 1) First obtain the base (usually by simply downloading it, but there is also an option now to create it with ROBOT) 2) We merge all base files into one big pile 3) Then we extract a single module imports/merged_import.owl The first implementation of this pipeline is PATO, see https://github.com/pato-ontology/pato/blob/master/src/ontology/pato-odk.yaml. To check if your ontology uses this method, check src/ontology/cl-odk.yaml to see if use_base_merging: TRUE is declared under import_group If your ontology uses Base Module approach, please use the following steps: First, add the term to be imported to the term file associated with it (see above \"Using term files\" section if this is not clear to you) Next, you navigate in your terminal to the ontology directory (underneath src in your hpo root directory). cd src/ontology Then refresh imports by running sh run.sh make imports/merged_import.owl Note: if your mirrors are updated, you can run sh run.sh make no-mirror-refresh-merged This requires quite a bit of memory on your local machine, so if you encounter an error, it might be a lack of memory on your computer. A solution would be to create a ticket in an issue tracker requesting for the term to be imported, and one of the local devs should pick this up and run the import for you. Lastly, restart Prot\u00e9g\u00e9, and the term should be imported in ready to be used.","title":"Using the Base Module approach"},{"location":"odk-workflows/components/","text":"Adding components to an ODK repo \u00b6 For details on what components are, please see component section of repository file structure document . To add custom components to an ODK repo, please follow the following steps: 1) Locate your odk yaml file and open it with your favourite text editor (src/ontology/cl-odk.yaml) 2) Search if there is already a component section to the yaml file, if not add it accordingly, adding the name of your component: components: products: - filename: your-component-name.owl 3) Refresh your repo by running sh run update_repo . This will automatically (1) create a new file in src/ontology/components/ , (2) update the -edit file so that it imports http://purl.obolibrary.org/obo/cl/components/your-component-name.owl (the IRI of your new component), and (3) update the XML catalog file ( src/ontology/catalog-v001.xml ) to redirect that IRI to the file in the src/ontology/components directory, so that the new component can be found by tools such as Prot\u00e9g\u00e9 or ROBOT, when they load the -edit file. If your component is to be generated by some automated process, add a goal in your custom Makefile ( src/ontology/cl.Makefile ) and make it perform any task needed to generate the component: $(COMPONENTSDIR)/your-component-name.owl: $(SRC) <Insert here the code to produce the component> If the component is to be generated from a ROBOT template, the ODK can generate the appropriate code for you. For that, when adding the component fo the ODK configuration file (step 2 above), explicitly indicate that the component should be derived from template(s) and list the source templates: components: products: - filename: your-component-name.owl use_template: true templates: - template1.tsv - template2.tsv In this example, the component will be derived from the templates found in src/templates/template1.tsv and src/templates/template2.tsv . Initial empty templates will automatically be generated when the repository is refreshed (step 3). Likewise, the ODK can generate the required code for the case where the component is to be derived from SSSOM mappings: components: products: - filename: your-component-name.owl use_mappings: true mappings: - my-mappings.sssom.tsv and for the case where the component is to be fetched from a remote resource: components: products: - filename: your-component-name.owl source: https://example.org/component-source.owl","title":"Adding components to an ODK repo"},{"location":"odk-workflows/components/#adding-components-to-an-odk-repo","text":"For details on what components are, please see component section of repository file structure document . To add custom components to an ODK repo, please follow the following steps: 1) Locate your odk yaml file and open it with your favourite text editor (src/ontology/cl-odk.yaml) 2) Search if there is already a component section to the yaml file, if not add it accordingly, adding the name of your component: components: products: - filename: your-component-name.owl 3) Refresh your repo by running sh run update_repo . This will automatically (1) create a new file in src/ontology/components/ , (2) update the -edit file so that it imports http://purl.obolibrary.org/obo/cl/components/your-component-name.owl (the IRI of your new component), and (3) update the XML catalog file ( src/ontology/catalog-v001.xml ) to redirect that IRI to the file in the src/ontology/components directory, so that the new component can be found by tools such as Prot\u00e9g\u00e9 or ROBOT, when they load the -edit file. If your component is to be generated by some automated process, add a goal in your custom Makefile ( src/ontology/cl.Makefile ) and make it perform any task needed to generate the component: $(COMPONENTSDIR)/your-component-name.owl: $(SRC) <Insert here the code to produce the component> If the component is to be generated from a ROBOT template, the ODK can generate the appropriate code for you. For that, when adding the component fo the ODK configuration file (step 2 above), explicitly indicate that the component should be derived from template(s) and list the source templates: components: products: - filename: your-component-name.owl use_template: true templates: - template1.tsv - template2.tsv In this example, the component will be derived from the templates found in src/templates/template1.tsv and src/templates/template2.tsv . Initial empty templates will automatically be generated when the repository is refreshed (step 3). Likewise, the ODK can generate the required code for the case where the component is to be derived from SSSOM mappings: components: products: - filename: your-component-name.owl use_mappings: true mappings: - my-mappings.sssom.tsv and for the case where the component is to be fetched from a remote resource: components: products: - filename: your-component-name.owl source: https://example.org/component-source.owl","title":"Adding components to an ODK repo"},{"location":"patterns/cellBearerOfQuality/","text":"cellBearerOfQuality \u00b6 http://purl.obolibrary.org/obo/cl/cellBearerOfQuality Description \u00b6 A cell that has a specific quality, such as binucleate. Contributors \u00b6 https://orcid.org/0000-0001-5208-3432 https://orcid.org/0000-0002-6601-2165 Name \u00b6 { quality } { cell } Annotations \u00b6 exact_synonym : { quality }d { cell } Definition \u00b6 Any { cell } that is { quality } Equivalent to \u00b6 { cell } and ( bearer of some { quality }) Data preview \u00b6 defined_class defined_class_label cell cell_label quality quality_label CL:0001061 abnormal cell CL:0000000 cell PATO:0000460 abnormal CL:0000225 anucleate cell CL:0000003 native cell PATO:0001405 anucleate CL:0000227 binucleate cell CL:0000003 native cell PATO:0001406 binucleate CL:0000103 bipolar neuron CL:0000099 interneuron PATO:0070006 bipolar morphology CL:4023077 bitufted neuron CL:0000099 interneuron PATO:0070012 bitufted cell morphology See full table here","title":"Cell, bearer of quality"},{"location":"patterns/cellBearerOfQuality/#cellbearerofquality","text":"http://purl.obolibrary.org/obo/cl/cellBearerOfQuality","title":"cellBearerOfQuality"},{"location":"patterns/cellBearerOfQuality/#description","text":"A cell that has a specific quality, such as binucleate.","title":"Description"},{"location":"patterns/cellBearerOfQuality/#contributors","text":"https://orcid.org/0000-0001-5208-3432 https://orcid.org/0000-0002-6601-2165","title":"Contributors"},{"location":"patterns/cellBearerOfQuality/#name","text":"{ quality } { cell }","title":"Name"},{"location":"patterns/cellBearerOfQuality/#annotations","text":"exact_synonym : { quality }d { cell }","title":"Annotations"},{"location":"patterns/cellBearerOfQuality/#definition","text":"Any { cell } that is { quality }","title":"Definition"},{"location":"patterns/cellBearerOfQuality/#equivalent-to","text":"{ cell } and ( bearer of some { quality })","title":"Equivalent to"},{"location":"patterns/cellBearerOfQuality/#data-preview","text":"defined_class defined_class_label cell cell_label quality quality_label CL:0001061 abnormal cell CL:0000000 cell PATO:0000460 abnormal CL:0000225 anucleate cell CL:0000003 native cell PATO:0001405 anucleate CL:0000227 binucleate cell CL:0000003 native cell PATO:0001406 binucleate CL:0000103 bipolar neuron CL:0000099 interneuron PATO:0070006 bipolar morphology CL:4023077 bitufted neuron CL:0000099 interneuron PATO:0070012 bitufted cell morphology See full table here","title":"Data preview"},{"location":"patterns/cellCapableOfBiologicalProcess/","text":"cellCapableOfBiologicalProcess \u00b6 http://purl.obolibrary.org/obo/cl/cellCapableOfBiologicalProcess Description \u00b6 Any cell that is involved in/capable of a particular biological process, such as acid secretion. Name \u00b6 { biological_process } { cell } Definition \u00b6 A { cell } that is capable of { biological_process }. Equivalent to \u00b6 { cell } and ( capable of some { biological_process }) Data preview \u00b6 defined_class defined_class_label biological_process biological_process_label cell cell_label CL:0000236 B cell GO:0019724 B cell mediated immunity CL:0000945 lymphocyte of B lineage CL:0000492 CD4-positive helper T cell GO:0001816 cytokine production CL:0000624 CD4-positive, alpha-beta T cell CL:0000795 CD8-positive, alpha-beta regulatory T cell GO:0050777 negative regulation of immune response CL:0000625 CD8-positive, alpha-beta T cell CL:0011005 GABAergic interneuron GO:0061534 gamma-aminobutyric acid secretion, neurotransmission CL:0000099 interneuron CL:0000617 GABAergic neuron GO:0061534 gamma-aminobutyric acid secretion, neurotransmission CL:0000540 neuron See full table here","title":"Cell, capable of Biological Process"},{"location":"patterns/cellCapableOfBiologicalProcess/#cellcapableofbiologicalprocess","text":"http://purl.obolibrary.org/obo/cl/cellCapableOfBiologicalProcess","title":"cellCapableOfBiologicalProcess"},{"location":"patterns/cellCapableOfBiologicalProcess/#description","text":"Any cell that is involved in/capable of a particular biological process, such as acid secretion.","title":"Description"},{"location":"patterns/cellCapableOfBiologicalProcess/#name","text":"{ biological_process } { cell }","title":"Name"},{"location":"patterns/cellCapableOfBiologicalProcess/#definition","text":"A { cell } that is capable of { biological_process }.","title":"Definition"},{"location":"patterns/cellCapableOfBiologicalProcess/#equivalent-to","text":"{ cell } and ( capable of some { biological_process })","title":"Equivalent to"},{"location":"patterns/cellCapableOfBiologicalProcess/#data-preview","text":"defined_class defined_class_label biological_process biological_process_label cell cell_label CL:0000236 B cell GO:0019724 B cell mediated immunity CL:0000945 lymphocyte of B lineage CL:0000492 CD4-positive helper T cell GO:0001816 cytokine production CL:0000624 CD4-positive, alpha-beta T cell CL:0000795 CD8-positive, alpha-beta regulatory T cell GO:0050777 negative regulation of immune response CL:0000625 CD8-positive, alpha-beta T cell CL:0011005 GABAergic interneuron GO:0061534 gamma-aminobutyric acid secretion, neurotransmission CL:0000099 interneuron CL:0000617 GABAergic neuron GO:0061534 gamma-aminobutyric acid secretion, neurotransmission CL:0000540 neuron See full table here","title":"Data preview"},{"location":"patterns/cellHasPlasmaMembranePartX/","text":"cellHasPlasmaMembranePartX \u00b6 http://purl.obolibrary.org/obo/cl/cellHasPlasmaMembranePartX Description \u00b6 A cell type that is characterized by a plasma membrane part, such as a cilium or receptor. Note - that this is only good for cells defined by a single plasma membrane receptor. Contributors \u00b6 https://orcid.org/0000-0001-5208-3432 https://orcid.org/0000-0002-6601-2165 Name \u00b6 { cell } { plasma_membrane } Annotations \u00b6 exact_synonym : { cell }-positive { plasma_membrane } Definition \u00b6 A { cell } that has a { plasma_membrane }. Equivalent to \u00b6 { cell } and ( has plasma membrane part some { plasma_membrane })","title":"Cell, has plasme membrane"},{"location":"patterns/cellHasPlasmaMembranePartX/#cellhasplasmamembranepartx","text":"http://purl.obolibrary.org/obo/cl/cellHasPlasmaMembranePartX","title":"cellHasPlasmaMembranePartX"},{"location":"patterns/cellHasPlasmaMembranePartX/#description","text":"A cell type that is characterized by a plasma membrane part, such as a cilium or receptor. Note - that this is only good for cells defined by a single plasma membrane receptor.","title":"Description"},{"location":"patterns/cellHasPlasmaMembranePartX/#contributors","text":"https://orcid.org/0000-0001-5208-3432 https://orcid.org/0000-0002-6601-2165","title":"Contributors"},{"location":"patterns/cellHasPlasmaMembranePartX/#name","text":"{ cell } { plasma_membrane }","title":"Name"},{"location":"patterns/cellHasPlasmaMembranePartX/#annotations","text":"exact_synonym : { cell }-positive { plasma_membrane }","title":"Annotations"},{"location":"patterns/cellHasPlasmaMembranePartX/#definition","text":"A { cell } that has a { plasma_membrane }.","title":"Definition"},{"location":"patterns/cellHasPlasmaMembranePartX/#equivalent-to","text":"{ cell } and ( has plasma membrane part some { plasma_membrane })","title":"Equivalent to"},{"location":"patterns/cellPartOfAnatomicalEntity/","text":"cellPartOfAnatomicalEntity \u00b6 http://purl.obolibrary.org/obo/cl/cellPartOfAnatomicalEntity Description \u00b6 A cell that is part of an anatomical entity. Contributors \u00b6 https://orcid.org/0000-0001-5208-3432 https://orcid.org/0000-0002-6601-2165 Name \u00b6 { cell } { anatomical_entity } Definition \u00b6 Any { cell } that is part of a { anatomical_entity }. Equivalent to \u00b6 { cell } and ( part of some { anatomical_entity }) Data preview \u00b6 defined_class defined_class_label anatomical_entity anatomical_entity_label cell cell_label CL:0009032 B cell of appendix UBERON:0001154 vermiform appendix CL:0000236 B cell CL:0009045 B cell of medullary sinus of lymph node UBERON:0009744 lymph node medullary sinus CL:0000236 B cell CL:0010007 His-Purkinje system cell UBERON:0004146 His-Purkinje system CL:0000003 native cell CL:0002680 PP cell of intestine UBERON:0000160 intestine CL:0000696 PP cell CL:0009015 Peyer's patch follicular dendritic cell UBERON:0001211 Peyer's patch CL:0000442 follicular dendritic cell See full table here","title":"Cell, part of anatomical entity"},{"location":"patterns/cellPartOfAnatomicalEntity/#cellpartofanatomicalentity","text":"http://purl.obolibrary.org/obo/cl/cellPartOfAnatomicalEntity","title":"cellPartOfAnatomicalEntity"},{"location":"patterns/cellPartOfAnatomicalEntity/#description","text":"A cell that is part of an anatomical entity.","title":"Description"},{"location":"patterns/cellPartOfAnatomicalEntity/#contributors","text":"https://orcid.org/0000-0001-5208-3432 https://orcid.org/0000-0002-6601-2165","title":"Contributors"},{"location":"patterns/cellPartOfAnatomicalEntity/#name","text":"{ cell } { anatomical_entity }","title":"Name"},{"location":"patterns/cellPartOfAnatomicalEntity/#definition","text":"Any { cell } that is part of a { anatomical_entity }.","title":"Definition"},{"location":"patterns/cellPartOfAnatomicalEntity/#equivalent-to","text":"{ cell } and ( part of some { anatomical_entity })","title":"Equivalent to"},{"location":"patterns/cellPartOfAnatomicalEntity/#data-preview","text":"defined_class defined_class_label anatomical_entity anatomical_entity_label cell cell_label CL:0009032 B cell of appendix UBERON:0001154 vermiform appendix CL:0000236 B cell CL:0009045 B cell of medullary sinus of lymph node UBERON:0009744 lymph node medullary sinus CL:0000236 B cell CL:0010007 His-Purkinje system cell UBERON:0004146 His-Purkinje system CL:0000003 native cell CL:0002680 PP cell of intestine UBERON:0000160 intestine CL:0000696 PP cell CL:0009015 Peyer's patch follicular dendritic cell UBERON:0001211 Peyer's patch CL:0000442 follicular dendritic cell See full table here","title":"Data preview"},{"location":"patterns/overview/","text":"Pattern directory \u00b6 This is a listing of all the patterns hosted as part of this directory Patterns in \u00b6 Cell bearer of quality \u00b6 A cell that has a specific quality, such as binucleate. Attribute Info IRI http://purl.obolibrary.org/obo/cl/cellBearerOfQuality Name cellBearerOfQuality Classes CL:0000000, PATO:0000001, Variables cell (CL:0000000), quality (PATO:0000001), Contributors 0000-0001-5208-3432 , 0000-0002-6601-2165 , Examples mondo Data preview: \u00b6 defined:class defined:class:label cell cell:label quality quality:label CL:0001061 abnormal cell CL:0000000 cell PATO:0000460 abnormal CL:0000225 anucleate cell CL:0000003 native cell PATO:0001405 anucleate CL:0000227 binucleate cell CL:0000003 native cell PATO:0001406 binucleate CL:0000103 bipolar neuron CL:0000099 interneuron PATO:0070006 bipolar morphology CL:4023077 bitufted neuron CL:0000099 interneuron PATO:0070012 bitufted cell morphology See full table here Cell capable of biological process \u00b6 Any cell that is involved in/capable of a particular biological process, such as acid secretion. Attribute Info IRI http://purl.obolibrary.org/obo/cl/cellCapableOfBiologicalProcess Name cellCapableOfBiologicalProcess Classes CL:0000000, GO:0008150, Variables cell (CL:0000000), biological_process (GO:0008150), Contributors Examples mondo Data preview: \u00b6 defined:class defined:class:label biological:process biological:process:label cell cell:label CL:0000236 B cell GO:0019724 B cell mediated immunity CL:0000945 lymphocyte of B lineage CL:0000492 CD4-positive helper T cell GO:0001816 cytokine production CL:0000624 CD4-positive, alpha-beta T cell CL:0000795 CD8-positive, alpha-beta regulatory T cell GO:0050777 negative regulation of immune response CL:0000625 CD8-positive, alpha-beta T cell CL:0011005 GABAergic interneuron GO:0061534 gamma-aminobutyric acid secretion, neurotransmission CL:0000099 interneuron CL:0000617 GABAergic neuron GO:0061534 gamma-aminobutyric acid secretion, neurotransmission CL:0000540 neuron See full table here Cell has plasma membrane part x \u00b6 A cell type that is characterized by a plasma membrane part, such as a cilium or receptor. Note - that this is only good for cells defined by a single plasma membrane receptor. Attribute Info IRI http://purl.obolibrary.org/obo/cl/cellHasPlasmaMembranePartX Name cellHasPlasmaMembranePartX Classes CL:0000000, CL:0000003, GO:0005886, Variables cell (CL:0000003), plasma_membrane (GO:0005886), Contributors 0000-0001-5208-3432 , 0000-0002-6601-2165 , Examples Cell part of anatomical entity \u00b6 A cell that is part of an anatomical entity. Attribute Info IRI http://purl.obolibrary.org/obo/cl/cellPartOfAnatomicalEntity Name cellPartOfAnatomicalEntity Classes CL:0000000, UBERON:0001062, Variables cell (CL:0000000), anatomical_entity (UBERON:0001062), Contributors 0000-0001-5208-3432 , 0000-0002-6601-2165 , Examples mondo Data preview: \u00b6 defined:class defined:class:label anatomical:entity anatomical:entity:label cell cell:label CL:0009032 B cell of appendix UBERON:0001154 vermiform appendix CL:0000236 B cell CL:0009045 B cell of medullary sinus of lymph node UBERON:0009744 lymph node medullary sinus CL:0000236 B cell CL:0010007 His-Purkinje system cell UBERON:0004146 His-Purkinje system CL:0000003 native cell CL:0002680 PP cell of intestine UBERON:0000160 intestine CL:0000696 PP cell CL:0009015 Peyer's patch follicular dendritic cell UBERON:0001211 Peyer's patch CL:0000442 follicular dendritic cell See full table here Taxon specific \u00b6 A cell that is restricted to a specific taxon, such as CL:0001200 'lymphocyte of B lineage, CD19-positive' are only in mammals. Note - this is not to be used for any cell that is restricted to a taxon, this is for taxon-specific subclasses of existing cell types. This should hardly ever be used. Attribute Info IRI http://purl.obolibrary.org/obo/cl/taxonSpecific Name taxonSpecific Classes CL:0000000, NCBITaxon:1, Variables cell (CL:0000000), taxon (NCBITaxon:1), Contributors 0000-0001-5208-3432 , 0000-0002-6601-2165 , Examples","title":"Design Patterns Overview"},{"location":"patterns/overview/#pattern-directory","text":"This is a listing of all the patterns hosted as part of this directory","title":"Pattern directory"},{"location":"patterns/overview/#patterns-in","text":"","title":"Patterns in"},{"location":"patterns/overview/#cell-bearer-of-quality","text":"A cell that has a specific quality, such as binucleate. Attribute Info IRI http://purl.obolibrary.org/obo/cl/cellBearerOfQuality Name cellBearerOfQuality Classes CL:0000000, PATO:0000001, Variables cell (CL:0000000), quality (PATO:0000001), Contributors 0000-0001-5208-3432 , 0000-0002-6601-2165 , Examples mondo","title":"Cell bearer of quality"},{"location":"patterns/overview/#data-preview","text":"defined:class defined:class:label cell cell:label quality quality:label CL:0001061 abnormal cell CL:0000000 cell PATO:0000460 abnormal CL:0000225 anucleate cell CL:0000003 native cell PATO:0001405 anucleate CL:0000227 binucleate cell CL:0000003 native cell PATO:0001406 binucleate CL:0000103 bipolar neuron CL:0000099 interneuron PATO:0070006 bipolar morphology CL:4023077 bitufted neuron CL:0000099 interneuron PATO:0070012 bitufted cell morphology See full table here","title":"Data preview:"},{"location":"patterns/overview/#cell-capable-of-biological-process","text":"Any cell that is involved in/capable of a particular biological process, such as acid secretion. Attribute Info IRI http://purl.obolibrary.org/obo/cl/cellCapableOfBiologicalProcess Name cellCapableOfBiologicalProcess Classes CL:0000000, GO:0008150, Variables cell (CL:0000000), biological_process (GO:0008150), Contributors Examples mondo","title":"Cell capable of biological process"},{"location":"patterns/overview/#data-preview_1","text":"defined:class defined:class:label biological:process biological:process:label cell cell:label CL:0000236 B cell GO:0019724 B cell mediated immunity CL:0000945 lymphocyte of B lineage CL:0000492 CD4-positive helper T cell GO:0001816 cytokine production CL:0000624 CD4-positive, alpha-beta T cell CL:0000795 CD8-positive, alpha-beta regulatory T cell GO:0050777 negative regulation of immune response CL:0000625 CD8-positive, alpha-beta T cell CL:0011005 GABAergic interneuron GO:0061534 gamma-aminobutyric acid secretion, neurotransmission CL:0000099 interneuron CL:0000617 GABAergic neuron GO:0061534 gamma-aminobutyric acid secretion, neurotransmission CL:0000540 neuron See full table here","title":"Data preview:"},{"location":"patterns/overview/#cell-has-plasma-membrane-part-x","text":"A cell type that is characterized by a plasma membrane part, such as a cilium or receptor. Note - that this is only good for cells defined by a single plasma membrane receptor. Attribute Info IRI http://purl.obolibrary.org/obo/cl/cellHasPlasmaMembranePartX Name cellHasPlasmaMembranePartX Classes CL:0000000, CL:0000003, GO:0005886, Variables cell (CL:0000003), plasma_membrane (GO:0005886), Contributors 0000-0001-5208-3432 , 0000-0002-6601-2165 , Examples","title":"Cell has plasma membrane part x"},{"location":"patterns/overview/#cell-part-of-anatomical-entity","text":"A cell that is part of an anatomical entity. Attribute Info IRI http://purl.obolibrary.org/obo/cl/cellPartOfAnatomicalEntity Name cellPartOfAnatomicalEntity Classes CL:0000000, UBERON:0001062, Variables cell (CL:0000000), anatomical_entity (UBERON:0001062), Contributors 0000-0001-5208-3432 , 0000-0002-6601-2165 , Examples mondo","title":"Cell part of anatomical entity"},{"location":"patterns/overview/#data-preview_2","text":"defined:class defined:class:label anatomical:entity anatomical:entity:label cell cell:label CL:0009032 B cell of appendix UBERON:0001154 vermiform appendix CL:0000236 B cell CL:0009045 B cell of medullary sinus of lymph node UBERON:0009744 lymph node medullary sinus CL:0000236 B cell CL:0010007 His-Purkinje system cell UBERON:0004146 His-Purkinje system CL:0000003 native cell CL:0002680 PP cell of intestine UBERON:0000160 intestine CL:0000696 PP cell CL:0009015 Peyer's patch follicular dendritic cell UBERON:0001211 Peyer's patch CL:0000442 follicular dendritic cell See full table here","title":"Data preview:"},{"location":"patterns/overview/#taxon-specific","text":"A cell that is restricted to a specific taxon, such as CL:0001200 'lymphocyte of B lineage, CD19-positive' are only in mammals. Note - this is not to be used for any cell that is restricted to a taxon, this is for taxon-specific subclasses of existing cell types. This should hardly ever be used. Attribute Info IRI http://purl.obolibrary.org/obo/cl/taxonSpecific Name taxonSpecific Classes CL:0000000, NCBITaxon:1, Variables cell (CL:0000000), taxon (NCBITaxon:1), Contributors 0000-0001-5208-3432 , 0000-0002-6601-2165 , Examples","title":"Taxon specific"},{"location":"patterns/taxonSpecific/","text":"taxonSpecific \u00b6 http://purl.obolibrary.org/obo/cl/taxonSpecific Description \u00b6 A cell that is restricted to a specific taxon, such as CL:0001200 'lymphocyte of B lineage, CD19-positive' are only in mammals. Note - this is not to be used for any cell that is restricted to a taxon, this is for taxon-specific subclasses of existing cell types. This should hardly ever be used. Contributors \u00b6 https://orcid.org/0000-0001-5208-3432 https://orcid.org/0000-0002-6601-2165 Name \u00b6 { cell }, { taxon } Definition \u00b6 Any { cell } that is part of a { taxon }. Equivalent to \u00b6 { cell } and ( in taxon some { taxon })","title":"Cell, taxon specific"},{"location":"patterns/taxonSpecific/#taxonspecific","text":"http://purl.obolibrary.org/obo/cl/taxonSpecific","title":"taxonSpecific"},{"location":"patterns/taxonSpecific/#description","text":"A cell that is restricted to a specific taxon, such as CL:0001200 'lymphocyte of B lineage, CD19-positive' are only in mammals. Note - this is not to be used for any cell that is restricted to a taxon, this is for taxon-specific subclasses of existing cell types. This should hardly ever be used.","title":"Description"},{"location":"patterns/taxonSpecific/#contributors","text":"https://orcid.org/0000-0001-5208-3432 https://orcid.org/0000-0002-6601-2165","title":"Contributors"},{"location":"patterns/taxonSpecific/#name","text":"{ cell }, { taxon }","title":"Name"},{"location":"patterns/taxonSpecific/#definition","text":"Any { cell } that is part of a { taxon }.","title":"Definition"},{"location":"patterns/taxonSpecific/#equivalent-to","text":"{ cell } and ( in taxon some { taxon })","title":"Equivalent to"}]}