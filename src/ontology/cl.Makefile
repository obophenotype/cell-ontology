## Customize Makefile settings for cl
##
## If you need to customize your Makefile, make
## changes here rather than in the main Makefile
# railing-whitespace  xref-syntax


# ----------------------------------------
# BUILDING RELEASE PRODUCTS
# ----------------------------------------

# Preprocessing: automatically generate text definitions from logical definitions
$(EDIT_PREPROCESSED): $(SRC) | all_robot_plugins
	$(ROBOT) flybase:rewrite-def -i $< --dot-definitions --null-definitions \
		                     --no-ids --filter-prefix CL_ \
		                     --add-annotation "oboInOwl:hasDbXref FBC:Autogenerated" \
		                     -o $@

# Building CL-plus (CL + PCL product)
# HACK: We have to remove the disjointness axioms between taxa, because
# PCL does not enforce taxon constraints and may contain TC violations
# that would be revealed here due to the presence of those axioms
# (thereby causing that step to fail). The proper fix would be for PCL
# to enforce TC.
# See <https://github.com/obophenotype/provisional_cell_ontology/issues/59>
cl-plus.owl: $(ONT)-full.owl
	$(ROBOT) merge -i $< -I $(OBOBASE)/pcl/pcl-base.owl \
		 unmerge -I $(OBOBASE)/ncbitaxon/subsets/taxslim-disjoint-over-in-taxon.owl \
		 reason --reasoner WHELK --equivalent-classes-allowed asserted-only \
		        --exclude-tautologies structural \
		 relax \
		 reduce --reasoner WHELK \
		 $(SHARED_ROBOT_COMMANDS) \
		 annotate --ontology-iri $(ONTBASE)/$@ \
		 $(ANNOTATE_ONTOLOGY_VERSION) --output $@

# Main release artefact (cl.owl)
# We override the standard ODK-generate rule so that we can merge in the
# tags for the taxon subsets.
POSTPROCESS_ADDITIONS = subsets/human-tags.ofn \
                        subsets/mouse-tags.ofn
$(ONT).owl: $(ONT)-full.owl $(POSTPROCESS_ADDITIONS)
	$(ROBOT) merge -i $< $(foreach add,$(POSTPROCESS_ADDITIONS),-i $(add)) \
		 annotate --ontology-iri $(URIBASE)/$@ $(ANNOTATE_ONTOLOGY_VERSION) \
		 convert -o $@


# ----------------------------------------
# SSSOM MAPPINGS
# ----------------------------------------

# CL's "local" mapping set (extracted from cross-references).
# The long list of "prefix-to-predicate" mapping is necessary because CL
# does not contain the oboInOwl:treat-xrefs-as-... annotations that are
# supposed to provide those mappings.
$(MAPPINGDIR)/cl-local.sssom.tsv: $(SRC) | all_robot_plugins
	$(ROBOT) sssom:xref-extract -i $< --mapping-file $@ -v --drop-duplicates \
		                    --prefix 'FMA:   http://purl.org/sig/ont/fma/fma' \
		                    --prefix 'KUPO:  http://purl.obolibrary.org/obo/KUPO_'  \
		                    --prefix 'SCTID: http://purl.obolibrary.org/obo/SCTID_' \
		                    --map-prefix-to-predicate 'AEO http://www.w3.org/2004/02/skos/core#exactMatch' \
		                    --map-prefix-to-predicate 'CARO http://www.w3.org/2004/02/skos/core#exactMatch' \
		                    --map-prefix-to-predicate 'GO http://www.w3.org/2004/02/skos/core#exactMatch' \
		                    --map-prefix-to-predicate 'VSAO http://www.w3.org/2004/02/skos/core#exactMatch' \
		                    --map-prefix-to-predicate 'VHOG http://www.w3.org/2004/02/skos/core#broadMatch' \
		                    --map-prefix-to-predicate 'EV http://www.w3.org/2004/02/skos/core#narrowMatch' \
		                    --map-prefix-to-predicate 'NCIT http://www.w3.org/2004/02/skos/core#narrowMatch' \
		                    --map-prefix-to-predicate 'SCTID http://www.w3.org/2004/02/skos/core#narrowMatch' \
		                    --map-prefix-to-predicate 'AAO https://w3id.org/semapv/vocab/crossSpeciesExactMatch' \
		                    --map-prefix-to-predicate 'EHDAA2 https://w3id.org/semapv/vocab/crossSpeciesExactMatch' \
		                    --map-prefix-to-predicate 'EMAPA https://w3id.org/semapv/vocab/crossSpeciesExactMatch' \
		                    --map-prefix-to-predicate 'FMA https://w3id.org/semapv/vocab/crossSpeciesExactMatch' \
		                    --map-prefix-to-predicate 'KUPO https://w3id.org/semapv/vocab/crossSpeciesExactMatch' \
		                    --map-prefix-to-predicate 'MA https://w3id.org/semapv/vocab/crossSpeciesExactMatch' \
		                    --map-prefix-to-predicate 'WBbt https://w3id.org/semapv/vocab/crossSpeciesExactMatch' \
		                    --map-prefix-to-predicate 'XAO https://w3id.org/semapv/vocab/crossSpeciesExactMatch' \
		                    --map-prefix-to-predicate 'ZFA https://w3id.org/semapv/vocab/crossSpeciesExactMatch' \
		                    --set-id http://purl.obolibrary.org/obo/cl/cl.sssom.tsv \
	> $(REPORTDIR)/cl-xrefs-extraction.txt

# CL's "meta" mapping set, made by compiling the "local" set above
# with the sets obtained from FBbt and ZFA below.
$(MAPPINGDIR)/cl.sssom.tsv: $(MAPPINGDIR)/cl-local.sssom.tsv \
			    $(MAPPINGDIR)/fbbt.sssom.tsv \
			    $(MAPPINGDIR)/zfa.sssom.tsv
	sssom-cli $(foreach src, $^, -i $(src)) \
		  --prefix-map-from-input \
		  --rule 'object==CL:* -> invert()' \
		  --rule 'subject==CL:* -> include()' \
		  --output $@

# Remote mapping sets
# -------------------

EXTERNAL_SSSOM_PROVIDERS = fbbt zfa
EXTERNAL_SSSOM_SETS = $(foreach provider, $(EXTERNAL_SSSOM_PROVIDERS), $(MAPPINGDIR)/$(provider).sssom.tsv)

# We only refresh external resources under MIR=true
ifeq ($(strip $(MIR)),true)

# FBbt mapping set
$(MAPPINGDIR)/fbbt.sssom.tsv: .FORCE
	wget -O - "http://purl.obolibrary.org/obo/fbbt/fbbt.sssom.tsv" | \
		sssom-cli --prefix-map-from-input \
		          --include 'object==CL:*' \
		          --update-from-ontology $(SRC):object,label,existence \
		          --output $@

# ZFA mapping set (extracted from ZFA cross-references).
# ZFA does contain oboInOwl:treat-xrefs-as-... annotations, but here
# it's easier to ignore them, as this automatically filters out all the
# xrefs that point to anything else than CL.
# 1. Create intermediate set from ZFA.
$(TMPDIR)/zfa.sssom.tsv: .FORCE | all_robot_plugins
	$(ROBOT) sssom:xref-extract -I http://purl.obolibrary.org/obo/zfa.owl \
		                    --mapping-file $@ -v --drop-duplicates \
		                    --ignore-treat-xrefs \
		                    --map-prefix-to-predicate 'CL https://w3id.org/semapv/vocab/crossSpeciesExactMatch' \
		                    --set-id http://purl.obolibrary.org/obo/zfa/zfa.sssom.tsv \
	> $(REPORTDIR)/xfa-xrefs-extraction

# 2. Create definitive ZFA set by checking against CL's contents
$(MAPPINGDIR)/zfa.sssom.tsv: $(TMPDIR)/zfa.sssom.tsv $(SRC)
	sssom-cli -i $< --update-from-ontology $(SRC):object,label,existence,source -o $@

endif

# Mappings component
# ------------------
# The mappings.owl component is derived from the remote mapping sets
# (as fetched above). It contains old-style cross-references to make
# those mappings "visible" to CL editors and users in the usual way.
$(COMPONENTSDIR)/mappings.owl: $(SRC) $(EXTERNAL_SSSOM_SETS) | all_robot_plugins
	$(ROBOT) sssom:inject -i $< \
			      $(foreach set, $(EXTERNAL_SSSOM_SETS), --sssom $(set)) \
			      --ruleset $(SCRIPTSDIR)/mappings-to-xrefs.rules \
			      --error-on-unshortenable-iris \
			      --no-merge --bridge-file $@ \
			      --bridge-iri http://purl.obolibrary.org/obo/cl/components/mappings.owl


# ----------------------------------------
# TAXON CONSTRAINTS CHECK
# ----------------------------------------

# The TC check requires te taxslim-disjoint-over-in-taxon.owl ontology,
# which is declared as an ODK mirror (under the name ncbitaxondisjoints)
# and as such should already have been downloaded into the mirror
# directory by the standard ODK-generated rule. But the QC checks are
# typically run under MIR=false, so while the standard rule would be
# invoked by Make it would not result in the mirror being downloaded.
# So instead, we make the TC check depend on another file, and here we
# 1. force the download of the mirror if it is not already there;
# 2. create a link to that mirror.
$(TMPDIR)/taxslim-disjoint-over-in-taxon.owl:
	if [ ! -f $(MIRRORDIR)/ncbitaxondisjoints.owl ]; then \
		$(MAKE) $(MIRRORDIR)/ncbitaxondisjoints.owl MIR=true IMP=true ; \
	fi && \
	ln -f -s ../$(MIRRORDIR)/ncbitaxondisjoints.owl $@

# Actual TC check: we add the taxon disjointness axioms into the
# ontology, make sure to expand all macros, then try to reason over the
# resulting product.
$(REPORTDIR)/taxon-constraint-check.txt: $(EDIT_PREPROCESSED) $(TMPDIR)/taxslim-disjoint-over-in-taxon.owl
	$(ROBOT) merge $(foreach src,$^,-i $(src)) \
		 expand -o $(TMPDIR)/cl-plus-taxon-disjoints.ofn \
		 reason -r WHELK > $@

# Include the TC check in the routine tests
test: $(REPORTDIR)/taxon-constraint-check.txt


# ----------------------------------------
# OTHER CUSTOM CHECKS
# ----------------------------------------

.PHONY: obocheck
obocheck: $(SRC) | all_robot_plugins
	$(ROBOT) merge -i $(SRC) \
		 remove --base-iri $(URIBASE)/CL_ --axioms external --trim false \
		 uberon:obo-export --merge-comments --obo-output $(TMPDIR)/cl-check.obo
	fastobo-validator $(TMPDIR)/cl-check.obo

test_obsolete: $(ONT).obo
	! grep "! obsolete" $<

test: obocheck \
      test_obsolete


# ----------------------------------------
# TAXON SUBSETS
# ----------------------------------------

TAXON_ID_human = NCBITaxon:9606
TAXON_ID_mouse = NCBITaxon:10090

# Create a taxon-specific subset. This rule creates two distinct files:
# (1) the subset proper (subsets/%-view.owl), which can be used on its
#     own (and can be published as a release artifact if desired);
# (2) a small containing oboInOwl:inSubset annotations to "tag" all
#     terms that belong to the subset (subsets/%-tags.ofn); that file
#     can then be combined with a CL release product.
.PRECIOUS: subsets/%-view.owl
subsets/%-view.owl subsets/%-tags.ofn: $(ONT)-full.owl | all_robot_plugins
	$(ROBOT) expand --input $< --expand-term RO:0002161 \
		 uberon:create-species-subset --taxon $(TAXON_ID_$*) \
		                              --strategy precise \
		                              --reasoner WHELK \
		                              --root CL:0000000 \
		                              --prefix 'cl: http://purl.obolibrary.org/obo/cl#' \
		                              --subset-name cl:$*_subset \
		                              --only-tag-in CL: \
		                              --write-tags-to subsets/$*-tags.ofn \
		 reason --reasoner WHELK --equivalent-classes-allowed all \
		        --exclude-tautologies structural \
		 relax \
		 remove --axioms equivalent \
		 reduce --reasoner WHELK \
		 annotate --ontology-iri $(ONTBASE)/subsets/$*-view.owl \
		          --version-iri $(ONTBASE)/releases/$(VERSION)/subsets/$*-view.owl \
		          --annotation owl:versionInfo $(VERSION) \
		 convert --format ofn --output subsets/$*-view.owl


# ----------------------------------------
# DOSDP PATTERNS HACKS
# ----------------------------------------

# Finding matches for DOSDP patterns. We can't use the ODK-generated
# workflow for that, because we need to exclude the ExtendedDescription
# pattern (which does not contain any logical definition to query
# against), something that the ODK does not allow to do.
# So we use the following convention: we find matches only for patterns
# whose filename starts with a lowercase letter (hereafter called the
# "queryable patterns"), instead of all patterns found in the patterns
# directory.
# See <https://github.com/obophenotype/cell-ontology/issues/2639>.
QUERYABLE_PATTERN_FILES=$(wildcard $(PATTERNDIR)/dosdp-patterns/[a-z]*.yaml)
QUERYABLE_PATTERN_NAMES=$(foreach f,$(QUERYABLE_PATTERN_FILES),$(basename $(notdir $f)))
.PHONY: matches
matches: $(SRC) $(QUERYABLE_PATTERN_FILES)
	$(DOSDPT) query --ontology=$< --catalog=$(CATALOG) \
		        --reasoner=elk --obo-prefixes=true \
		        --batch-patterns="$(QUERYABLE_PATTERN_NAMES)" \
		        --template="$(PATTERNDIR)/dosdp-patterns" \
		        --outfile="$(PATTERNDIR)/data/matches/"

# Generating documentation for the DOSDP patterns
# FIXME: This is currently broken, see
# <https://github.com/obophenotype/cell-ontology/issues/2636>.
# Also, ideally this should be provided by the ODK, see
# <https://github.com/INCATools/ontology-development-kit/issues/1101>.
.PHONY: pattern_docs
pattern_docs: $(ALL_PATTERN_FILES)
	dosdp document -i $(PATTERNDIR)/dosdp-patterns/ \
		       -d $(PATTERNDIR)/data/matches/ \
		       -o ../../docs/patterns/


# ----------------------------------------
# CUSTOM OBO OUTPUT
# ----------------------------------------
OBO_EXPORT_OPTIONS = --merge-comments --strip-gci-axioms --strip-owl-axioms

$(SUBSETDIR)/%.obo: $(SUBSETDIR)/%.owl | all_robot_plugins
	$(ROBOT) uberon:obo-export --input $< $(OBO_EXPORT_OPTIONS) --obo-output $@

$(ONT).obo: $(ONT).owl | all_robot_plugins
	$(ROBOT) uberon:obo-export --input $< $(OBO_EXPORT_OPTIONS) --obo-output $@

$(ONT)-base.obo: $(ONT)-base.owl | all_robot_plugins
	$(ROBOT) uberon:obo-export --input $< $(OBO_EXPORT_OPTIONS) --obo-output $@

$(ONT)-full.obo: $(ONT)-full.owl | all_robot_plugins
	$(ROBOT) uberon:obo-export --input $< $(OBO_EXPORT_OPTIONS) --obo-output $@

$(ONT)-simple.obo: $(ONT)-simple.owl | all_robot_plugins
	$(ROBOT) uberon:obo-export --input $< $(OBO_EXPORT_OPTIONS) --obo-output $@

$(ONT)-basic.obo: $(ONT)-basic.owl | all_robot_plugins
	$(ROBOT) uberon:obo-export --input $< $(OBO_EXPORT_OPTIONS) --obo-output $@

$(ONT)-non-classified.obo: $(ONT)-non-classified.owl | all_robot_plugins
	$(ROBOT) uberon:obo-export --input $< $(OBO_EXPORT_OPTIONS) --obo-output $@

cl-plus.obo: cl-plus.owl | all_robot_plugins
	$(ROBOT) uberon:obo-export --input $< $(OBO_EXPORT_OPTIONS) --obo-output $@


# ----------------------------------------
# DIFFS/REPORTS
# ----------------------------------------

# Diffs against the master branch on GitHub
# -----------------------------------------
# Two variants: with and without the imports.
# Not automatically generated from amywhere, but available on demand
# by calling `make branch_diffs`.

CL_EDIT_GITHUB_MASTER = https://raw.githubusercontent.com/obophenotype/cell-ontology/master/src/ontology/cl-edit.owl

$(TMPDIR)/src-noimports.owl: $(SRC)
	$(ROBOT) remove -i $< --select imports -o $@

$(TMPDIR)/src-imports.owl: $(SRC)
	$(ROBOT) merge -i $< -o $@

$(TMPDIR)/src-master-noimports.owl:
	$(ROBOT) remove -I $(CL_EDIT_GITHUB_MASTER) --select imports -o $@

$(TMPDIR)/src-master-imports.owl:
	$(ROBOT) merge -I $(CL_EDIT_GITHUB_MASTER) -o $@

$(TMPDIR)/diff_edit_%.md: $(TMPDIR)/src-master-%.owl $(TMPDIR)/src-%.owl
	$(ROBOT) diff --left $(TMPDIR)/src-master-$*.owl --right $(TMPDIR)/src-$*.owl -f markdown -o $@

$(TMPDIR)/diff_edit_%.txt: $(TMPDIR)/src-master-%.owl $(TMPDIR)/src-%.owl
	$(ROBOT) diff --left $(TMPDIR)/src-master-$*.owl --right $(TMPDIR)/src-$*.owl -o $@

branch_diffs: $(REPORTDIR)/diff_edit_imports.md \
	      $(REPORTDIR)/diff_edit_noimports.md \
	      $(REPORTDIR)/diff_edit_imports.txt \
	      $(REPORTDIR)/diff_edit_noimports.txt


# Diff against the latest released version
# ----------------------------------------
# FIXME: It's unclear whether this diff is still desired. It is only
# generated when `all_reports` is explicitly invoked. Upon releasing, we
# now produce more complete diffs against the latest public base (see
# RELEASE DEPLOYMENT below), likely making this diff no longer relevant.
# See <https://github.com/obophenotype/cell-ontology/issues/2641>.

$(TMPDIR)/cl-current.owl: $(ONT).owl
	$(ROBOT) remove -i $< --term rdfs:label \
		        --select complement --select annotation-properties \
		 remove --base-iri $(URIBASE)/CL_ --axioms external -o $@

$(TMPDIR)/cl-lastbuild.owl: .FORCE
	$(ROBOT) remove -I $(URIBASE)/$(ONT).owl --term rdfs:label \
		        --select complement --select annotation-properties \
		 remove --base-iri $(URIBASE)/CL_ --axioms external -o $@

$(REPORTDIR)/obo-diff.txt: $(TMPDIR)/cl-lastbuild.owl $(TMPDIR)/cl-current.owl
	$(ROBOT) diff --left $< --right $(TMPDIR)/cl-current.owl -f markdown -o $@

all_reports: $(REPORTDIR)/obo-diff.txt


# ----------------------------------------
# UTILITY COMMANDS
# ----------------------------------------

# Remove alternative ID from the -edit file
rm-altid:
	$(ROBOT) query -i $(SRC) --format ttl \
		       --query $(SPARQLDIR)/rm-obsolete-alt-id.ru \
		       $(TMPDIR)/cl-updated.ttl
	$(ROBOT) unmerge -i $(SRC) -i $(TMPDIR)/cl-updated.ttl \
		 convert -f ofn -o $(SRC)

# Inject replaced_by (IAO:0100001) annotations in the -edit file
add-replacedby:
	$(ROBOT) query -i $(SRC) --format ttl \
		       --query $(SPARQLDIR)/construct-replaced-by.sparql \
		       $(TMPDIR)/cl-construct-replaced-by.ttl
	$(ROBOT) merge -i $(SRC) -i $(TMPDIR)/cl-construct-replaced-by.ttl \
		       --collapse-import-closure false \
		 convert -f ofn -o $(SRC)


# ----------------------------------------
# EXTERNAL RESOURCES
# ----------------------------------------

ifeq ($(strip $(MIR)),true)

# Human reference atlas subset
HRA_SUBSET_URL="https://raw.githubusercontent.com/hubmapconsortium/ccf-validation-tools/master/owl/CL_ASCTB_subset.owl"
$(TMPDIR)/hra_subset.owl:
	wget $(HRA_SUBSET_URL) -O $@

$(COMPONENTSDIR)/hra_subset.owl: $(TMPDIR)/hra_subset.owl
	$(ROBOT) merge -i $< annotate --ontology-iri $(ONTBASE)/$@ --output $@

# CellXGene reference subset
CELLXGENE_SUBSET_URL="https://raw.githubusercontent.com/hkir-dev/cellxgene-cell-reporter/main/templates/cellxgene_subset.tsv"
$(TEMPLATEDIR)/cellxgene_subset.tsv: .FORCE
	wget $(CELLXGENE_SUBSET_URL) -O $@

# CellMark reference subset
CLM_CL_URL="https://raw.githubusercontent.com/Cellular-Semantics/CellMark/main/clm-cl.owl"
$(TMPDIR)/clm-cl.owl:
	wget $(CLM_CL_URL) -O $@

$(COMPONENTSDIR)/clm-cl.owl: $(TMPDIR)/clm-cl.owl
	$(ROBOT) merge -i $< annotate --ontology-iri $(ONTBASE)/$@ --output $@

endif


# ----------------------------------------
# RELEASE DEPLOYMENT
# ----------------------------------------

DEPLOY_GH=true

.PHONY: cl
cl:
	$(MAKE) prepare_release IMP=false PAT=false MIR=false
	$(MAKE) release-base-diff
	$(MAKE) prepare_content_summary
	if [ $(DEPLOY_GH) = true ]; then 	$(MAKE) deploy_release GHVERSION="v$(TODAY)"; fi

CURRENT_BASE_RELEASE=$(ONTBASE)/cl-base.obo

.PHONY: $(TMPDIR)/current-base-release.obo
$(TMPDIR)/current-base-release.obo:
	wget $(CURRENT_BASE_RELEASE) -O $@

.PHONY: release-base-diff
release-base-diff: $(TMPDIR)/current-base-release.obo $(RELEASEDIR)/cl-base.obo
	$(ROBOT) diff --labels True -f markdown --left $(TMPDIR)/current-base-release.obo --right $(RELEASEDIR)/cl-base.obo --output reports/$(ONT)-base-diff.md

.PHONY: prepare_content_summary
prepare_content_summary: $(RELEASEDIR)/cl-base.owl $(RELEASEDIR)/cl-base.obo $(TMPDIR)/current-base-release.obo custom_reports
	python ./$(SCRIPTSDIR)/content_summary.py --ontology_iri $< --ont_namespace "CL" > $(REPORTDIR)/ontology_content.md
	runoak -i simpleobo:$(TMPDIR)/current-base-release.obo diff -X simpleobo:$(RELEASEDIR)/cl-base.obo -o $(REPORTDIR)/diff_release_oak.md --output-type md
	cat $(REPORTDIR)/ontology_content.md $(REPORTDIR)/diff_release_oak.md > $(REPORTDIR)/summary_release.md
		
FILTER_OUT=../patterns/definitions.owl ../patterns/pattern.owl reports/cl-edit.owl-obo-report.tsv
MAIN_FILES_RELEASE = $(foreach n, $(filter-out $(FILTER_OUT), $(RELEASE_ASSETS)), ../../$(n)) \
		     $(MAPPINGDIR)/cl.sssom.tsv

deploy_release:
	@test $(GHVERSION)
	ls -alt $(MAIN_FILES_RELEASE)
	gh release create $(GHVERSION) --notes "TBD." --title "$(GHVERSION)" --draft $(MAIN_FILES_RELEASE)  --generate-notes


# -------------------------------------------
# UPPER SLIM VALIDATION AND COVERAGE REPORTS
# -------------------------------------------

TERM_hematopoietic= CL:0000988
TERM_eye= UBERON:0000970
TERM_general = CL:0000000
TERM_kidney= UBERON:0002113

SLIM_TEMPLATES= blood_and_immune eye general_cell_types kidney
SLIM_REPORTS = $(foreach n,$(SLIM_TEMPLATES),$(REPORTDIR)/$(n)_upper_slim.csv)

.PHONY: slim_coverage
slim_coverage: $(SLIM_REPORTS)

COVERAGECMD= ./$(SCRIPTSDIR)/generic_coverage.py -s $(TERM_ID) -f $< -o $@ -c makefile

$(REPORTDIR)/blood_and_immune_upper_slim_report.csv: $(TEMPLATEDIR)/blood_and_immune_upper_slim.csv
	$(eval TERM_ID := $(TERM_hematopoietic))
	$(COVERAGECMD)

$(REPORTDIR)/eye_upper_slim_report.csv: $(TEMPLATEDIR)/eye_upper_slim.csv
	$(eval TERM_ID := $(TERM_eye))
	$(COVERAGECMD)

$(REPORTDIR)/general_cell_types_upper_slim_report.csv: $(TEMPLATEDIR)/general_cell_types_upper_slim.csv
	$(eval TERM_ID := $(TERM_general))
	$(COVERAGECMD)

$(REPORTDIR)/kidney_upper_slim_report.csv: $(TEMPLATEDIR)/kidney_upper_slim.csv
	$(eval TERM_ID := $(TERM_kidney))
	$(COVERAGECMD)
